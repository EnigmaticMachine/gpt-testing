1. [Refactoring].

285 286

Chapter 17: Smells and Heuristics

I compiled this list by walking through several different programs and refactoring them. As I made each change, I asked myself why I made that change and then wrote the reason down here. The result is a rather long list of things that smell bad to me when I read code.

This list is meant to be read from top to bottom and also to be used as a reference. There is a cross-reference for each heuristic that shows you where it is referenced in the rest of the text in “Appendix C” on page 409.

Comments

C1: Inappropriate Information

It is inappropriate for a comment to hold information better held in a different kind of system such as your source code control system, your issue tracking system, or any other record-keeping system. Change histories, for example, just clutter up source ﬁles with volumes of historical and uninteresting text. In general, meta-data such as authors, lastmodiﬁed-date, SPR number, and so on should not appear in comments. Comments should be reserved for technical notes about the code and design.

C2: Obsolete Comment

A comment that has gotten old, irrelevant, and incorrect is obsolete. Comments get old quickly. It is best not to write a comment that will become obsolete. If you ﬁnd an obsolete comment, it is best to update it or get rid of it as quickly as possible. Obsolete comments tend to migrate away from the code they once described. They become ﬂoating islands of irrelevance and misdirection in the code.

C3: Redundant Comment

A comment is redundant if it describes something that adequately describes itself. For example:

i++; // increment i

Another example is a Javadoc that says nothing more than (or even less than) the function signature:

/** * @param sellRequest * @return * @throws ManagedComponentException */ public SellResponse beginSellItem(SellRequest sellRequest) throws ManagedComponentException

Comments should say things that the code cannot say for itself. Environment

287

C4: Poorly Written Comment

A comment worth writing is worth writing well. If you are going to write a comment, take the time to make sure it is the best comment you can write. Choose your words carefully. Use correct grammar and punctuation. Don’t ramble. Don’t state the obvious. Be brief.

C5: Commented-Out Code

It makes me crazy to see stretches of code that are commented out. Who knows how old it is? Who knows whether or not it’s meaningful? Yet no one will delete it because everyone assumes someone else needs it or has plans for it.

That code sits there and rots, getting less and less relevant with every passing day. It calls functions that no longer exist. It uses variables whose names have changed. It follows conventions that are long obsolete. It pollutes the modules that contain it and distracts the people who try to read it. Commented-out code is an abomination.

When you see commented-out code, delete it! Don’t worry, the source code control system still remembers it. If anyone really needs it, he or she can go back and check out a previous version. Don’t suffer commented-out code to survive.

Environment

E1: Build Requires More Than One Step

Building a project should be a single trivial operation. You should not have to check many little pieces out from source code control. You should not need a sequence of arcane commands or context dependent scripts in order to build the individual elements. You should not have to search near and far for all the various little extra JARs, XML ﬁles, and other artifacts that the system requires. You should be able to check out the system with one simple command and then issue one other simple command to build it.

svn get mySystem cd mySystem ant all

E2: Tests Require More Than One Step

You should be able to run all the unit tests with just one command. In the best case you can run all the tests by clicking on one button in your IDE. In the worst case you should be able to issue a single simple command in a shell. Being able to run all the tests is so fundamental and so important that it should be quick, easy, and obvious to do. 288

Chapter 17: Smells and Heuristics

Functions

F1: Too Many Arguments

Functions should have a small number of arguments. No argument is best, followed by one, two, and three. More than three is very questionable and should be avoided with prejudice. (See “Function Arguments” on page 40.)

F2: Output Arguments

Output arguments are counterintuitive. Readers expect arguments to be inputs, not outputs. If your function must change the state of something, have it change the state of the object it is called on. (See “Output Arguments” on page 45.)

F3: Flag Arguments

Boolean arguments loudly declare that the function does more than one thing. They are confusing and should be eliminated. (See “Flag Arguments” on page 41.)

F4: Dead Function

Methods that are never called should be discarded. Keeping dead code around is wasteful. Don’t be afraid to delete the function. Remember, your source code control system still remembers it.

General

G1: Multiple Languages in One Source File

Today’s modern programming environments make it possible to put many different languages into a single source ﬁle. For example, a Java source ﬁle might contain snippets of XML, HTML, YAML, JavaDoc, English, JavaScript, and so on. For another example, in addition to HTML a JSP ﬁle might contain Java, a tag library syntax, English comments, Javadocs, XML, JavaScript, and so forth. This is confusing at best and carelessly sloppy at worst.

The ideal is for a source ﬁle to contain one, and only one, language. Realistically, we will probably have to use more than one. But we should take pains to minimize both the number and extent of extra languages in our source ﬁles.

G2: Obvious Behavior Is Unimplemented

Following “The Principle of Least Surprise,” 2 any function or class should implement the behaviors that another programmer could reasonably expect. For example, consider a function that translates the name of a day to an enum that represents the day.

2. Or “The Principle of Least Astonishment”: http://en.wikipedia.org/wiki/ Principle_of_least_astonishment General

289

Day day = DayDate.StringToDay(String dayName); We would expect the string "Monday" to be translated to Day.MONDAY. We would also expect

the common abbreviations to be translated, and we would expect the function to ignore case.

When an obvious behavior is not implemented, readers and users of the code can no longer depend on their intuition about function names. They lose their trust in the original author and must fall back on reading the details of the code.

G3: Incorrect Behavior at the Boundaries

It seems obvious to say that code should behave correctly. The problem is that we seldom realize just how complicated correct behavior is. Developers often write functions that they think will work, and then trust their intuition rather than going to the effort to prove that their code works in all the corner and boundary cases.

There is no replacement for due diligence. Every boundary condition, every corner case, every quirk and exception represents something that can confound an elegant and intuitive algorithm. Don’t rely on your intuition. Look for every boundary condition and write a test for it.

G4: Overridden Safeties

Chernobyl melted down because the plant manager overrode each of the safety mechanisms one by one. The safeties were making it inconvenient to run an experiment. The result was that the experiment did not get run, and the world saw it’s ﬁrst major civilian nuclear catastrophe.

It is risky to override safeties. Exerting manual control over serialVersionUID may be necessary, but it is always risky. Turning off certain compiler warnings (or all warnings!) may help you get the build to succeed, but at the risk of endless debugging sessions. Turning off failing tests and telling yourself you’ll get them to pass later is as bad as pretending your credit cards are free money.

G5: Duplication

This is one of the most important rules in this book, and you should take it very seriously. Virtually every author who writes about software design mentions this rule. Dave Thomas and Andy Hunt called it the DRY 3 principle (Don’t Repeat Yourself). Kent Beck made it one of the core principles of Extreme Programming and called it: “Once, and only once.” Ron Jeffries ranks this rule second, just below getting all the tests to pass.

Every time you see duplication in the code, it represents a missed opportunity for abstraction. That duplication could probably become a subroutine or perhaps another class outright. By folding the duplication into such an abstraction, you increase the vocabulary of the language of your design. Other programmers can use the abstract facilities

3. [PRAG]. 290

Chapter 17: Smells and Heuristics

you create. Coding becomes faster and less error prone because you have raised the abstraction level.

The most obvious form of duplication is when you have clumps of identical code that look like some programmers went wild with the mouse, pasting the same code over and over again. These should be replaced with simple methods.

A more subtle form is the switch/case or if/else chain that appears again and again in various modules, always testing for the same set of conditions. These should be replaced with polymorphism.

Still more subtle are the modules that have similar algorithms, but that don’t share similar lines of code. This is still duplication and should be addressed by using the TEM4 PLATE METHOD, or STRATEGY 5 pattern.

Indeed, most of the design patterns that have appeared in the last ﬁfteen years are simply well-known ways to eliminate duplication. So too the Codd Normal Forms are a strategy for eliminating duplication in database schemae. OO itself is a strategy for organizing modules and eliminating duplication. Not surprisingly, so is structured programming.

I think the point has been made. Find and eliminate duplication wherever you can.

G6: Code at Wrong Level of Abstraction

It is important to create abstractions that separate higher level general concepts from lower level detailed concepts. Sometimes we do this by creating abstract classes to hold the higher level concepts and derivatives to hold the lower level concepts. When we do this, we need to make sure that the separation is complete. We want all the lower level concepts to be in the derivatives and all the higher level concepts to be in the base class.

For example, constants, variables, or utility functions that pertain only to the detailed implementation should not be present in the base class. The base class should know nothing about them.

This rule also pertains to source ﬁles, components, and modules. Good software design requires that we separate concepts at different levels and place them in different containers. Sometimes these containers are base classes or derivatives and sometimes they are source ﬁles, modules, or components. Whatever the case may be, the separation needs to be complete. We don’t want lower and higher level concepts mixed together.

Consider the following code:

public interface Stack {

Object pop() throws EmptyException; void push(Object o) throws FullException; double percentFull();

4. [GOF].

5. [GOF]. General

291

class EmptyException extends Exception {} class FullException extends Exception {}

}

The percentFull function is at the wrong level of abstraction. Although there are many implementations of Stack where the concept of fullness is reasonable, there are other implementations that simply could not know how full they are. So the function would be better placed in a derivative interface such as BoundedStack.

Perhaps you are thinking that the implementation could just return zero if the stack were boundless. The problem with that is that no stack is truly boundless. You cannot really prevent an OutOfMemoryException by checking for

stack.percentFull() < 50.0.

Implementing the function to return 0 would be telling a lie.

The point is that you cannot lie or fake your way out of a misplaced abstraction. Isolating abstractions is one of the hardest things that software developers do, and there is no quick ﬁx when you get it wrong.

G7: Base Classes Depending on Their Derivatives

The most common reason for partitioning concepts into base and derivative classes is so that the higher level base class concepts can be independent of the lower level derivative class concepts. Therefore, when we see base classes mentioning the names of their derivatives, we suspect a problem. In general, base classes should know nothing about their derivatives.

There are exceptions to this rule, of course. Sometimes the number of derivatives is strictly ﬁxed, and the base class has code that selects between the derivatives. We see this a lot in ﬁnite state machine implementations. However, in that case the derivatives and base class are strongly coupled and always deploy together in the same jar ﬁle. In the general case we want to be able to deploy derivatives and bases in different jar ﬁles.

Deploying derivatives and bases in different jar ﬁles and making sure the base jar ﬁles know nothing about the contents of the derivative jar ﬁles allow us to deploy our systems in discrete and independent components. When such components are modiﬁed, they can be redeployed without having to redeploy the base components. This means that the impact of a change is greatly lessened, and maintaining systems in the ﬁeld is made much simpler.

G8: Too Much Information

Well-deﬁned modules have very small interfaces that allow you to do a lot with a little. Poorly deﬁned modules have wide and deep interfaces that force you to use many different gestures to get simple things done. A well-deﬁned interface does not offer very many functions to depend upon, so coupling is low. A poorly deﬁned interface provides lots of functions that you must call, so coupling is high. 292

Chapter 17: Smells and Heuristics

Good software developers learn to limit what they expose at the interfaces of their classes and modules. The fewer methods a class has, the better. The fewer variables a function knows about, the better. The fewer instance variables a class has, the better.

Hide your data. Hide your utility functions. Hide your constants and your temporaries. Don’t create classes with lots of methods or lots of instance variables. Don’t create lots of protected variables and functions for your subclasses. Concentrate on keeping interfaces very tight and very small. Help keep coupling low by limiting information.

G9: Dead Code

Dead code is code that isn’t executed. You ﬁnd it in the body of an if statement that checks for a condition that can’t happen. You ﬁnd it in the catch block of a try that never throws. You ﬁnd it in little utility methods that are never called or switch/case conditions that never occur.

The problem with dead code is that after awhile it starts to smell. The older it is, the stronger and sourer the odor becomes. This is because dead code is not completely updated when designs change. It still compiles, but it does not follow newer conventions or rules. It was written at a time when the system was different. When you ﬁnd dead code, do the right thing. Give it a decent burial. Delete it from the system.

G10: Vertical Separation

Variables and function should be deﬁned close to where they are used. Local variables should be declared just above their ﬁrst usage and should have a small vertical scope. We don’t want local variables declared hundreds of lines distant from their usages.

Private functions should be deﬁned just below their ﬁrst usage. Private functions belong to the scope of the whole class, but we’d still like to limit the vertical distance between the invocations and deﬁnitions. Finding a private function should just be a matter of scanning downward from the ﬁrst usage.

G11: Inconsistency

If you do something a certain way, do all similar things in the same way. This goes back to the principle of least surprise. Be careful with the conventions you choose, and once chosen, be careful to continue to follow them.

If within a particular function you use a variable named response to hold an HttpServletResponse, then use the same variable name consistently in the other functions that use HttpServletResponse objects. If you name a method processVerificationRequest, then use a similar name, such as processDeletionRequest, for the methods that process other kinds of requests.

Simple consistency like this, when reliably applied, can make code much easier to read and modify. General

293

G12: Clutter

Of what use is a default constructor with no implementation? All it serves to do is clutter up the code with meaningless artifacts. Variables that aren’t used, functions that are never called, comments that add no information, and so forth. All these things are clutter and should be removed. Keep your source ﬁles clean, well organized, and free of clutter.

G13: Artiﬁcial Coupling

Things that don’t depend upon each other should not be artiﬁcially coupled. For example, general enums should not be contained within more speciﬁc classes because this forces the whole application to know about these more speciﬁc classes. The same goes for general purpose static functions being declared in speciﬁc classes.

In general an artiﬁcial coupling is a coupling between two modules that serves no direct purpose. It is a result of putting a variable, constant, or function in a temporarily convenient, though inappropriate, location. This is lazy and careless.

Take the time to ﬁgure out where functions, constants, and variables ought to be declared. Don’t just toss them in the most convenient place at hand and then leave them there.

G14: Feature Envy

This is one of Martin Fowler’s code smells. 6 The methods of a class should be interested in the variables and functions of the class they belong to, and not the variables and functions of other classes. When a method uses accessors and mutators of some other object to manipulate the data within that object, then it envies the scope of the class of that other object. It wishes that it were inside that other class so that it could have direct access to the variables it is manipulating. For example:

public class HourlyPayCalculator {

public Money calculateWeeklyPay(HourlyEmployee e) { int tenthRate = e.getTenthRate().getPennies(); int tenthsWorked = e.getTenthsWorked(); int straightTime = Math.min(400, tenthsWorked); int overTime = Math.max(0, tenthsWorked - straightTime); int straightPay = straightTime * tenthRate; int overtimePay = (int)Math.round(overTime*tenthRate*1.5); return new Money(straightPay + overtimePay); }

}

The calculateWeeklyPay method reaches into the HourlyEmployee object to get the data on which it operates. The calculateWeeklyPay method envies the scope of HourlyEmployee. It “wishes” that it could be inside HourlyEmployee.

6. [Refactoring]. 294

Chapter 17: Smells and Heuristics

All else being equal, we want to eliminate Feature Envy because it exposes the internals of one class to another. Sometimes, however, Feature Envy is a necessary evil. Consider the following:

public class HourlyEmployeeReport { private HourlyEmployee employee ;

public HourlyEmployeeReport(HourlyEmployee e) { this.employee = e; }

String reportHours() { return String.format( "Name: %s\tHours:%d.%1d\n", employee.getName(), employee.getTenthsWorked()/10, employee.getTenthsWorked()%10); }

}

Clearly, the reportHours method envies the HourlyEmployee class. On the other hand, we don’t want HourlyEmployee to have to know about the format of the report. Moving that format string into the HourlyEmployee class would violate several principles of object oriented design. 7 It would couple HourlyEmployee to the format of the report, exposing it to changes in that format.

G15: Selector Arguments

There is hardly anything more abominable than a dangling false argument at the end of a function call. What does it mean? What would it change if it were true? Not only is the purpose of a selector argument difﬁcult to remember, each selector argument combines many functions into one. Selector arguments are just a lazy way to avoid splitting a large function into several smaller functions. Consider:

public int calculateWeeklyPay(boolean overtime) { int tenthRate = getTenthRate(); int tenthsWorked = getTenthsWorked(); int straightTime = Math.min(400, tenthsWorked); int overTime = Math.max(0, tenthsWorked - straightTime); int straightPay = straightTime * tenthRate; double overtimeRate = overtime ? 1.5 : 1.0 * tenthRate; int overtimePay = (int)Math.round(overTime*overtimeRate); return straightPay + overtimePay; }

You call this function with a true if overtime is paid as time and a half, and with a false if overtime is paid as straight time. It’s bad enough that you must remember what calculateWeeklyPay(false) means whenever you happen to stumble across it. But the

7. Speciﬁcally, the Single Responsibility Principle, the Open Closed Principle, and the Common Closure Principle. See [PPP]. General

295

real shame of a function like this is that the author missed the opportunity to write the following:

public int straightPay() { return getTenthsWorked() * getTenthRate(); }

public int overTimePay() { int overTimeTenths = Math.max(0, getTenthsWorked() - 400); int overTimePay = overTimeBonus(overTimeTenths); return straightPay() + overTimePay; }

private int overTimeBonus(int overTimeTenths) { double bonus = 0.5 * getTenthRate() * overTimeTenths; return (int) Math.round(bonus); }

Of course, selectors need not be boolean. They can be enums, integers, or any other type of argument that is used to select the behavior of the function. In general it is better to have many functions than to pass some code into a function to select the behavior.

G16: Obscured Intent

We want code to be as expressive as possible. Run-on expressions, Hungarian notation, and magic numbers all obscure the author’s intent. For example, here is the overTimePay function as it might have appeared:

public int m_otCalc() { return iThsWkd * iThsRte + (int) Math.round(0.5 * iThsRte * Math.max(0, iThsWkd - 400) ); }

Small and dense as this might appear, it’s also virtually impenetrable. It is worth taking the time to make the intent of our code visible to our readers.

G17: Misplaced Responsibility

One of the most important decisions a software developer can make is where to put code. For example, where should the PI constant go? Should it be in the Math class? Perhaps it belongs in the Trigonometry class? Or maybe in the Circle class?

The principle of least surprise comes into play here. Code should be placed where a reader would naturally expect it to be. The PI constant should go where the trig functions are declared. The OVERTIME_RATE constant should be declared in the HourlyPayCalculator class.

Sometimes we get “clever” about where to put certain functionality. We’ll put it in a function that’s convenient for us, but not necessarily intuitive to the reader. For example, perhaps we need to print a report with the total of hours that an employee worked. We 296

Chapter 17: Smells and Heuristics

could sum up those hours in the code that prints the report, or we could try to keep a running total in the code that accepts time cards.

One way to make this decision is to look at the names of the functions. Let’s say that our report module has a function named getTotalHours. Let’s also say that the module that accepts time cards has a saveTimeCard function. Which of these two functions, by it’s name, implies that it calculates the total? The answer should be obvious.

Clearly, there are sometimes performance reasons why the total should be calculated as time cards are accepted rather than when the report is printed. That’s ﬁne, but the names of the functions ought to reﬂect this. For example, there should be a computeRunningTotalOfHours function in the timecard module.

G18: Inappropriate Static

Math.max(double a, double b) is a good static method. It does not operate on a single instance; indeed, it would be silly to have to say new Math().max(a,b) or even a.max(b). All the data that max uses comes from its two arguments, and not from any “owning” object. More to the point, there is almost no chance that we’d want Math.max to be polymorphic.

Sometimes, however, we write static functions that should not be static. For example, consider:

HourlyPayCalculator.calculatePay(employee, overtimeRate).

Again, this seems like a reasonable static function. It doesn’t operate on any particular object and gets all it’s data from it’s arguments. However, there is a reasonable chance that we’ll want this function to be polymorphic. We may wish to implement several different algorithms for calculating hourly pay, for example, OvertimeHourlyPayCalculator and StraightTimeHourlyPayCalculator. So in this case the function should not be static. It should be a nonstatic member function of Employee.

In general you should prefer nonstatic methods to static methods. When in doubt, make the function nonstatic. If you really want a function to be static, make sure that there is no chance that you’ll want it to behave polymorphically.

G19: Use Explanatory Variables

Kent Beck wrote about this in his great book Smalltalk Best Practice Patterns 8 and again more recently in his equally great book Implementation Patterns. 9 One of the more powerful ways to make a program readable is to break the calculations up into intermediate values that are held in variables with meaningful names.

8. [Beck97], p. 108.

9. [Beck07]. General

297

Consider this example from FitNesse:

Matcher match = headerPattern.matcher(line); if(match.find()) {

String key = match.group(1);

String value = match.group(2);

headers.put(key.toLowerCase(), value); }

The simple use of explanatory variables makes it clear that the ﬁrst matched group is the key, and the second matched group is the value.

It is hard to overdo this. More explanatory variables are generally better than fewer. It is remarkable how an opaque module can suddenly become transparent simply by breaking the calculations up into well-named intermediate values.

G20: Function Names Should Say What They Do

Look at this code:

Date newDate = date.add(5);

Would you expect this to add ﬁve days to the date? Or is it weeks, or hours? Is the date instance changed or does the function just return a new Date without changing the old one? You can’t tell from the call what the function does.

If the function adds ﬁve days to the date and changes the date, then it should be called addDaysTo or increaseByDays. If, on the other hand, the function returns a new date that is ﬁve days later but does not change the date instance, it should be called daysLater or daysSince.

If you have to look at the implementation (or documentation) of the function to know what it does, then you should work to ﬁnd a better name or rearrange the functionality so that it can be placed in functions with better names.

G21: Understand the Algorithm

Lots of very funny code is written because people don’t take the time to understand the algorithm. They get something to work by plugging in enough if statements and ﬂags, without really stopping to consider what is really going on.

Programming is often an exploration. You think you know the right algorithm for something, but then you wind up ﬁddling with it, prodding and poking at it, until you get it to “work.” How do you know it “works”? Because it passes the test cases you can think of.

There is nothing wrong with this approach. Indeed, often it is the only way to get a function to do what you think it should. However, it is not sufﬁcient to leave the quotation marks around the word “work.” 298

Chapter 17: Smells and Heuristics

Before you consider yourself to be done with a function, make sure you understand how it works. It is not good enough that it passes all the tests. You must know 10 that the solution is correct.

Often the best way to gain this knowledge and understanding is to refactor the function into something that is so clean and expressive that it is obvious how it works.

G22: Make Logical Dependencies Physical

If one module depends upon another, that dependency should be physical, not just logical. The dependent module should not make assumptions (in other words, logical dependencies) about the module it depends upon. Rather it should explicitly ask that module for all the information it depends upon.

For example, imagine that you are writing a function that prints a plain text report of hours worked by employees. One class named HourlyReporter gathers all the data into a convenient form and then passes it to HourlyReportFormatter to print it. (See Listing 17-1.)

Listing 17-1 HourlyReporter.java

public class HourlyReporter {

private HourlyReportFormatter formatter; private List<LineItem> page; private final int PAGE_SIZE = 55;

public HourlyReporter(HourlyReportFormatter formatter) { this.formatter = formatter;

page = new ArrayList<LineItem>();

}

public void generateReport(List<HourlyEmployee> employees) { for (HourlyEmployee e : employees) { addLineItemToPage(e); if (page.size() == PAGE_SIZE) printAndClearItemList(); } if (page.size() > 0) printAndClearItemList(); }

private void printAndClearItemList() { formatter.format(page); page.clear(); }

private void addLineItemToPage(HourlyEmployee e) { LineItem item = new LineItem(); item.name = e.getName(); item.hours = e.getTenthsWorked() / 10;

10. There is a difference between knowing how the code works and knowing whether the algorithm will do the job required of it.

Being unsure that an algorithm is appropriate is often a fact of life. Being unsure what your code does is just laziness. General

299

Listing 17-1 (continued) HourlyReporter.java

item.tenths = e.getTenthsWorked() % 10; page.add(item);

}

public class LineItem { public String name; public int hours; public int tenths; }

}

This code has a logical dependency that has not been physicalized. Can you spot it? It is the constant PAGE_SIZE. Why should the HourlyReporter know the size of the page? Page size should be the responsibility of the HourlyReportFormatter.

The fact that PAGE_SIZE is declared in HourlyReporter represents a misplaced responsibility [G17] that causes HourlyReporter to assume that it knows what the page size ought to be. Such an assumption is a logical dependency. HourlyReporter depends on the fact that HourlyReportFormatter can deal with page sizes of 55. If some implementation of HourlyReportFormatter could not deal with such sizes, then there would be an error.

We can physicalize this dependency by creating a new method in HourlyReportFormatter named getMaxPageSize(). HourlyReporter will then call that function rather than using the PAGE_SIZE constant.

G23: Prefer Polymorphism to If/Else or Switch/Case

This might seem a strange suggestion given the topic of Chapter 6. After all, in that chapter I make the point that switch statements are probably appropriate in the parts of the system where adding new functions is more likely than adding new types.

First, most people use switch statements because it’s the obvious brute force solution, not because it’s the right solution for the situation. So this heuristic is here to remind us to consider polymorphism before using a switch.

Second, the cases where functions are more volatile than types are relatively rare. So every switch statement should be suspect.

I use the following “ONE SWITCH” rule: There may be no more than one switch statement for a given type of selection. The cases in that switch statement must create polymorphic objects that take the place of other such switch statements in the rest of the system.

G24: Follow Standard Conventions

Every team should follow a coding standard based on common industry norms. This coding standard should specify things like where to declare instance variables; how to name classes, methods, and variables; where to put braces; and so on. The team should not need a document to describe these conventions because their code provides the examples. 300

Chapter 17: Smells and Heuristics

Everyone on the team should follow these conventions. This means that each team member must be mature enough to realize that it doesn’t matter a whit where you put your braces so long as you all agree on where to put them.

If you would like to know what conventions I follow, you’ll see them in the refactored code in Listing B-7 on page 394, through Listing B-14.

G25: Replace Magic Numbers with Named Constants

This is probably one of the oldest rules in software development. I remember reading it in the late sixties in introductory COBOL, FORTRAN, and PL/1 manuals. In general it is a bad idea to have raw numbers in your code. You should hide them behind well-named constants.

example, the number 86,400 should be hidden behind the constant SECONDS_PER_DAY. If you are printing 55 lines per page, then the constant 55 should be hidden behind the constant LINES_PER_PAGE.

For

Some constants are so easy to recognize that they don’t always need a named constant to hide behind so long as they are used in conjunction with very self-explanatory code. For example:

double milesWalked = feetWalked/5280.0;

int dailyPay = hourlyRate * 8; double circumference = radius * Math.PI * 2;

Do we really need the constants FEET_PER_MILE, WORK_HOURS_PER_DAY, and TWO in the above examples? Clearly, the last case is absurd. There are some formulae in which constants are simply better written as raw numbers. You might quibble about the WORK_HOURS_PER_DAY case because the laws or conventions might change. On the other hand, that formula reads so nicely with the 8 in it that I would be reluctant to add 17 extra characters to the readers’ burden. And in the FEET_PER_MILE case, the number 5280 is so very well known and so unique a constant that readers would recognize it even if it stood alone on a page with no context surrounding it.

Constants like 3.141592653589793 are also very well known and easily recognizable. However, the chance for error is too great to leave them raw. Every time someone sees 3.1415927535890793, they know that it is p, and so they fail to scrutinize it. (Did you catch the single-digit error?) We also don’t want people using 3.14, 3.14159, 3.142, and so forth. Therefore, it is a good thing that Math.PI has already been deﬁned for us.

The term “Magic Number” does not apply only to numbers. It applies to any token that has a value that is not self-describing. For example:

assertEquals(7777, Employee.find(“John Doe”).employeeNumber());

There are two magic numbers in this assertion. The ﬁrst is obviously 7777, though what it might mean is not obvious. The second magic number is "John Doe," and again the intent is not clear.

It turns out that "John Doe" is the name of employee #7777 in a well-known test database created by our team. Everyone in the team knows that when you connect to this General

301

database, it will have several employees already cooked into it with well-known values and attributes. It also turns out that "John Doe" represents the sole hourly employee in that test database. So this test should really read:

assertEquals(

HOURLY_EMPLOYEE_ID, Employee.find(HOURLY_EMPLOYEE_NAME).employeeNumber());

G26: Be Precise

Expecting the ﬁrst match to be the only match to a query is probably naive. Using ﬂoating point numbers to represent currency is almost criminal. Avoiding locks and/or transaction management because you don’t think concurrent update is likely is lazy at best. Declaring a variable to be an ArrayList when a List will due is overly constraining. Making all variables protected by default is not constraining enough.

When you make a decision in your code, make sure you make it precisely. Know why you have made it and how you will deal with any exceptions. Don’t be lazy about the precision of your decisions. If you decide to call a function that might return null, make sure you check for null. If you query for what you think is the only record in the database, make sure your code checks to be sure there aren’t others. If you need to deal with currency, use integers 11 and deal with rounding appropriately. If there is the possibility of concurrent update, make sure you implement some kind of locking mechanism.

Ambiguities and imprecision in code are either a result of disagreements or laziness. In either case they should be eliminated.

G27: Structure over Convention

Enforce design decisions with structure over convention. Naming conventions are good, but they are inferior to structures that force compliance. For example, switch/cases with nicely named enumerations are inferior to base classes with abstract methods. No one is forced to implement the switch/case statement the same way each time; but the base classes do enforce that concrete classes have all abstract methods implemented.

G28: Encapsulate Conditionals

Boolean logic is hard enough to understand without having to see it in the context of an if or while statement. Extract functions that explain the intent of the conditional.

For example:

if (shouldBeDeleted(timer))

is preferable to

if (timer.hasExpired() && !timer.isRecurrent())

11. Or better yet, a Money class that uses integers. 302

Chapter 17: Smells and Heuristics

G29: Avoid Negative Conditionals

Negatives are just a bit harder to understand than positives. So, when possible, conditionals should be expressed as positives. For example:

if (buffer.shouldCompact())

is preferable to

if (!buffer.shouldNotCompact())

G30: Functions Should Do One Thing

It is often tempting to create functions that have multiple sections that perform a series of operations. Functions of this kind do more than one thing, and should be converted into many smaller functions, each of which does one thing.

For example:

public void pay() { for (Employee e : employees) { if (e.isPayday()) { Money pay = e.calculatePay(); e.deliverPay(pay); } } }

This bit of code does three things. It loops over all the employees, checks to see whether each employee ought to be paid, and then pays the employee. This code would be better written as:

public void pay() { for (Employee e : employees) payIfNecessary(e); }

private void payIfNecessary(Employee e) { if (e.isPayday()) calculateAndDeliverPay(e); }

private void calculateAndDeliverPay(Employee e) { Money pay = e.calculatePay(); e.deliverPay(pay); }

Each of these functions does one thing. (See “Do One Thing” on page 35.)

G31: Hidden Temporal Couplings

Temporal couplings are often necessary, but you should not hide the coupling. Structure the arguments of your functions such that the order in which they should be called is obvious. Consider the following: General

303

public class MoogDiver { Gradient gradient; List<Spline> splines;

public void dive(String reason) { saturateGradient(); reticulateSplines(); diveForMoog(reason); } ...

}

The order of the three functions is important. You must saturate the gradient before you can reticulate the splines, and only then can you dive for the moog. Unfortunately, the code does not enforce this temporal coupling. Another programmer could call reticulateSplines before saturateGradient was called, leading to an UnsaturatedGradientException. A better solution is:

public class MoogDiver { Gradient gradient; List<Spline> splines;

public void dive(String reason) { Gradient gradient = saturateGradient();

List<Spline> splines = reticulateSplines(gradient);

diveForMoog(splines, reason);

} ...

}

This exposes the temporal coupling by creating a bucket brigade. Each function produces a result that the next function needs, so there is no reasonable way to call them out of order.

You might complain that this increases the complexity of the functions, and you’d be right. But that extra syntactic complexity exposes the true temporal complexity of the situation.

Note that I left the instance variables in place. I presume that they are needed by private methods in the class. Even so, I want the arguments in place to make the temporal coupling explicit.

G32: Don’t Be Arbitrary

Have a reason for the way you structure your code, and make sure that reason is communicated by the structure of the code. If a structure appears arbitrary, others will feel empowered to change it. If a structure appears consistently throughout the system, others will use it and preserve the convention. For example, I was recently merging changes to FitNesse and discovered that one of our committers had done this:

public class AliasLinkWidget extends ParentWidget {

public static class VariableExpandingWidgetRoot { ...

...

} 304

Chapter 17: Smells and Heuristics

The problem with this was that VariableExpandingWidgetRoot had no need to be inside the scope of AliasLinkWidget. Moreover, other unrelated classes made use of AliasLinkWidget.VariableExpandingWidgetRoot. These classes had no need to know about AliasLinkWidget.

Perhaps the programmer had plopped the VariableExpandingWidgetRoot into AliasWidget as a matter of convenience, or perhaps he thought it really needed to be scoped inside AliasWidget. Whatever the reason, the result wound up being arbitrary. Public classes that are not utilities of some other class should not be scoped inside another class. The convention is to make them public at the top level of their package.

G33: Encapsulate Boundary Conditions

Boundary conditions are hard to keep track of. Put the processing for them in one place. Don’t let them leak all over the code. We don’t want swarms of +1s and -1s scattered hither and yon. Consider this simple example from FIT:

if(level + 1 < tags.length) {

parts = new Parse(body, tags, level + 1, offset + endTag);

body = null; }

Notice that level+1 appears twice. This is a boundary condition that should be encapsulated within a variable named something like nextLevel.

int nextLevel = level + 1; if(nextLevel < tags.length) {

parts = new Parse(body, tags, nextLevel, offset + endTag);

body = null; }

G34: Functions Should Descend Only One Level of Abstraction

The statements within a function should all be written at the same level of abstraction, which should be one level below the operation described by the name of the function. This may be the hardest of these heuristics to interpret and follow. Though the idea is plain enough, humans are just far too good at seamlessly mixing levels of abstraction. Consider, for example, the following code taken from FitNesse:

public String render() throws Exception {

StringBuffer html = new StringBuffer("<hr"); if(size > 0) html.append(" size=\"").append(size + 1).append("\""); html.append(">");

return html.toString();

} General

305

A moment’s study and you can see what’s going on. This function constructs the HTML tag that draws a horizontal rule across the page. The height of that rule is speciﬁed in the size variable.

Now look again. This method is mixing at least two levels of abstraction. The ﬁrst is the notion that a horizontal rule has a size. The second is the syntax of the HR tag itself. This code comes from the HruleWidget module in FitNesse. This module detects a row of four or more dashes and converts it into the appropriate HR tag. The more dashes, the larger the size.

I refactored this bit of code as follows. Note that I changed the name of the size ﬁeld to reﬂect its true purpose. It held the number of extra dashes.

public String render() throws Exception { HtmlTag hr = new HtmlTag("hr"); if (extraDashes > 0) hr.addAttribute("size", hrSize(extraDashes)); return hr.html(); }

private String hrSize(int height) {

int hrSize = height + 1;

return String.format("%d", hrSize); }

This change separates the two levels of abstraction nicely. The render function simply constructs an HR tag, without having to know anything about the HTML syntax of that tag. The HtmlTag module takes care of all the nasty syntax issues.

Indeed, by making this change I caught a subtle error. The original code did not put the closing slash on the HR tag, as the XHTML standard would have it. (In other words, it emitted <hr> instead of <hr/>.) The HtmlTag module had been changed to conform to XHTML long ago.

Separating levels of abstraction is one of the most important functions of refactoring, and it’s one of the hardest to do well. As an example, look at the code below. This was my ﬁrst attempt at separating the abstraction levels in the HruleWidget.render method.

public String render() throws Exception {

HtmlTag hr = new HtmlTag("hr"); if (size > 0) {

hr.addAttribute("size", ""+(size+1));

} return hr.html();

}

My goal, at this point, was to create the necessary separation and get the tests to pass. I accomplished that goal easily, but the result was a function that still had mixed levels of abstraction. In this case the mixed levels were the construction of the HR tag and the 306

Chapter 17: Smells and Heuristics

interpretation and formatting of the size variable. This points out that when you break a function along lines of abstraction, you often uncover new lines of abstraction that were obscured by the previous structure.

G35: Keep Conﬁgurable Data at High Levels

If you have a constant such as a default or conﬁguration value that is known and expected at a high level of abstraction, do not bury it in a low-level function. Expose it as an argument to that low-level function called from the high-level function. Consider the following code from FitNesse:

public static void main(String[] args) throws Exception {

Arguments arguments = parseCommandLine(args);

... }

public class Arguments { public static final String DEFAULT_PATH = "."; public static final String DEFAULT_ROOT = "FitNesseRoot"; public static final int DEFAULT_PORT = 80; public static final int DEFAULT_VERSION_DAYS = 14; ...

}

The command-line arguments are parsed in the very ﬁrst executable line of FitNesse. The default values of those arguments are speciﬁed at the top of the Argument class. You don’t have to go looking in low levels of the system for statements like this one:

if (arguments.port == 0) // use 80 by default

The conﬁguration constants reside at a very high level and are easy to change. They get passed down to the rest of the application. The lower levels of the application do not own the values of these constants.

G36: Avoid Transitive Navigation

In general we don’t want a single module to know much about its collaborators. More speciﬁcally, if A collaborates with B, and B collaborates with C, we don’t want modules that use A to know about C. (For example, we don’t want a.getB().getC().doSomething();.)

This is sometimes called the Law of Demeter. The Pragmatic Programmers call it “Writing Shy Code.” 12 In either case it comes down to making sure that modules know only about their immediate collaborators and do not know the navigation map of the whole system.

If many modules used some form of the statement a.getB().getC(), then it would be difﬁcult to change the design and architecture to interpose a Q between B and C. You’d

12. [PRAG], p. 138. Java

307

have to ﬁnd every instance of a.getB().getC() and convert it to a.getB().getQ().getC(). This is how architectures become rigid. Too many modules know too much about the architecture.

Rather we want our immediate collaborators to offer all the services we need. We should not have to roam through the object graph of the system, hunting for the method we want to call. Rather we should simply be able to say:

myCollaborator.doSomething().

Java

J1: Avoid Long Import Lists by Using Wildcards

If you use two or more classes from a package, then import the whole package with

import package.*;

Long lists of imports are daunting to the reader. We don’t want to clutter up the tops of our modules with 80 lines of imports. Rather we want the imports to be a concise statement about which packages we collaborate with.

Speciﬁc imports are hard dependencies, whereas wildcard imports are not. If you speciﬁcally import a class, then that class must exist. But if you import a package with a wildcard, no particular classes need to exist. The import statement simply adds the package to the search path when hunting for names. So no true dependency is created by such imports, and they therefore serve to keep our modules less coupled.

There are times when the long list of speciﬁc imports can be useful. For example, if you are dealing with legacy code and you want to ﬁnd out what classes you need to build mocks and stubs for, you can walk down the list of speciﬁc imports to ﬁnd out the true qualiﬁed names of all those classes and then put the appropriate stubs in place. However, this use for speciﬁc imports is very rare. Furthermore, most modern IDEs will allow you to convert the wildcarded imports to a list of speciﬁc imports with a single command. So even in the legacy case it’s better to import wildcards.

Wildcard imports can sometimes cause name conﬂicts and ambiguities. Two classes with the same name, but in different packages, will need to be speciﬁcally imported, or at least speciﬁcally qualiﬁed when used. This can be a nuisance but is rare enough that using wildcard imports is still generally better than speciﬁc imports.

J2: Don’t Inherit Constants

I have seen this several times and it always makes me grimace. A programmer puts some constants in an interface and then gains access to those constants by inheriting that interface. Take a look at the following code:

public class HourlyEmployee extends Employee { private int tenthsWorked; private double hourlyRate; 308

Chapter 17: Smells and Heuristics

public Money calculatePay() { int straightTime = Math.min(tenthsWorked, TENTHS_PER_WEEK); int overTime = tenthsWorked - straightTime; return new Money( hourlyRate * (tenthsWorked + OVERTIME_RATE * overTime) ); } ...

}

Where did the constants TENTHS_PER_WEEK and OVERTIME_RATE come from? They might have come from class Employee; so let’s take a look at that:

public abstract class Employee implements PayrollConstants { public abstract boolean isPayday(); public abstract Money calculatePay(); public abstract void deliverPay(Money pay); }

Nope, not there. But then where? Look closely at class Employee. It implements PayrollConstants.

public interface PayrollConstants { public static final int TENTHS_PER_WEEK = 400; public static final double OVERTIME_RATE = 1.5; }

This is a hideous practice! The constants are hidden at the top of the inheritance hierarchy. Ick! Don’t use inheritance as a way to cheat the scoping rules of the language. Use a static import instead.

import static PayrollConstants.*;

public class HourlyEmployee extends Employee { private int tenthsWorked; private double hourlyRate;

public Money calculatePay() { int straightTime = Math.min(tenthsWorked, TENTHS_PER_WEEK); int overTime = tenthsWorked - straightTime; return new Money( hourlyRate * (tenthsWorked + OVERTIME_RATE * overTime) ); } ...

}

J3: Constants versus Enums

Now that enums have been added to the language (Java 5), use them! Don’t keep using the old trick of public static final ints. The meaning of ints can get lost. The meaning of enums cannot, because they belong to an enumeration that is named.

What’s more, study the syntax for enums carefully. They can have methods and ﬁelds. This makes them very powerful tools that allow much more expression and ﬂexibility than ints. Consider this variation on the payroll code: Names

309

public class HourlyEmployee extends Employee { private int tenthsWorked; HourlyPayGrade grade;

public Money calculatePay() { int straightTime = Math.min(tenthsWorked, TENTHS_PER_WEEK); int overTime = tenthsWorked - straightTime; return new Money( grade.rate() * (tenthsWorked + OVERTIME_RATE * overTime) ); } ...

}

public enum HourlyPayGrade { APPRENTICE { public double rate() { return 1.0; } }, LEUTENANT_JOURNEYMAN { public double rate() { return 1.2; } }, JOURNEYMAN { public double rate() { return 1.5; } }, MASTER { public double rate() { return 2.0; } };

public abstract double rate();

}

Names

N1: Choose Descriptive Names

Don’t be too quick to choose a name. Make sure the name is descriptive. Remember that meanings tend to drift as software evolves, so frequently reevaluate the appropriateness of the names you choose.

This is not just a “feel-good” recommendation. Names in software are 90 percent of what make software readable. You need to take the time to choose them wisely and keep them relevant. Names are too important to treat carelessly.

Consider the code below. What does it do? If I show you the code with well-chosen names, it will make perfect sense to you, but like this it’s just a hodge-podge of symbols and magic numbers. 310

Chapter 17: Smells and Heuristics

public int x() {

int q = 0;

int z = 0;

for (int kk = 0; kk < 10; kk++) {

if (l[z] == 10) {

q += 10 + (l[z + 1] + l[z + 2]);

z += 1;

} else if (l[z] + l[z + 1] == 10) {

q += 10 + l[z + 2];

z += 2;

} else {

q += l[z] + l[z + 1];

z += 2;

}

} return q;

}

Here is the code the way it should be written. This snippet is actually less complete than the one above. Yet you can infer immediately what it is trying to do, and you could very likely write the missing functions based on that inferred meaning. The magic numbers are no longer magic, and the structure of the algorithm is compellingly descriptive.

public int score() { int score = 0; int frame = 0;

for (int frameNumber = 0; frameNumber < 10; frameNumber++) {

if (isStrike(frame)) { score += 10 + nextTwoBallsForStrike(frame); frame += 1; } else if (isSpare(frame)) { score += 10 + nextBallForSpare(frame); frame += 2; } else { score += twoBallsInFrame(frame); frame += 2; }

} return score;

}

The power of carefully chosen names is that they overload the structure of the code with description. That overloading sets the readers’ expectations about what the other functions in the module do. You can infer the implementation of isStrike() by looking at the code above. When you read the isStrike method, it will be “pretty much what you expected.”13 

private boolean isStrike(int frame) {

return rolls[frame] == 10;

}

13. See Ward Cunningham’s quote on page 11. Names

311

N2: Choose Names at the Appropriate Level of Abstraction

Don’t pick names that communicate implementation; choose names the reﬂect the level of abstraction of the class or function you are working in. This is hard to do. Again, people are just too good at mixing levels of abstractions. Each time you make a pass over your code, you will likely ﬁnd some variable that is named at too low a level. You should take the opportunity to change those names when you ﬁnd them. Making code readable requires a dedication to continuous improvement. Consider the Modem interface below:

public interface Modem { boolean dial(String phoneNumber); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber(); }

At ﬁrst this looks ﬁne. The functions all seem appropriate. Indeed, for many applications they are. But now consider an application in which some modems aren’t connected by dialling. Rather they are connected permanently by hard wiring them together (think of the cable modems that provide Internet access to most homes nowadays). Perhaps some are connected by sending a port number to a switch over a USB connection. Clearly the notion of phone numbers is at the wrong level of abstraction. A better naming strategy for this scenario might be:

public interface Modem { boolean connect(String connectionLocator); boolean disconnect(); boolean send(char c); char recv(); String getConnectedLocator(); }

Now the names don’t make any commitments about phone numbers. They can still be used for phone numbers, or they could be used for any other kind of connection strategy.

N3: Use Standard Nomenclature Where Possible

Names are easier to understand if they are based on existing convention or usage. For example, if you are using the DECORATOR pattern, you should use the word Decorator in the names of the decorating classes. For example, AutoHangupModemDecorator might be the name of a class that decorates a Modem with the ability to automatically hang up at the end of a session.

Patterns are just one kind of standard. In Java, for example, functions that convert objects to string representations are often named toString. It is better to follow conventions like these than to invent your own.

Teams will often invent their own standard system of names for a particular project. Eric Evans refers to this as a ubiquitous language for the project. 14 Your code should use

14. [DDD]. 312

Chapter 17: Smells and Heuristics

the terms from this language extensively. In short, the more you can use names that are overloaded with special meanings that are relevant to your project, the easier it will be for readers to know what your code is talking about.

N4: Unambiguous Names

Choose names that make the workings of a function or variable unambiguous. Consider this example from FitNesse:

private String doRename() throws Exception {

if(refactorReferences) renameReferences(); renamePage();

pathToRename.removeNameFromEnd(); pathToRename.addNameToEnd(newName); return PathParser.render(pathToRename);

}

The name of this function does not say what the function does except in broad and vague terms. This is emphasized by the fact that there is a function named renamePage inside the function named doRename! What do the names tell you about the difference between the two functions? Nothing.

A better name for that function is renamePageAndOptionallyAllReferences. This may seem long, and it is, but it’s only called from one place in the module, so it’s explanatory value outweighs the length.

N5: Use Long Names for Long Scopes

The length of a name should be related to the length of the scope. You can use very short variable names for tiny scopes, but for big scopes you should use longer names.

Variable names like i and j are just ﬁne if their scope is ﬁve lines long. Consider this snippet from the old standard “Bowling Game”:

private void rollMany(int n, int pins) {

for (int i=0; i<n; i++)

g.roll(pins);

}

This is perfectly clear and would be obfuscated if the variable i were replaced with something annoying like rollCount. On the other hand, variables and functions with short names lose their meaning over long distances. So the longer the scope of the name, the longer and more precise the name should be.

N6: Avoid Encodings

Names should not be encoded with type or scope information. Preﬁxes such as m_ or f are useless in today’s environments. Also project and/or subsystem encodings such as Tests

313

vis_ (for visual imaging system) are distracting and redundant. Again, today’s environments provide all that information without having to mangle the names. Keep your names free of Hungarian pollution.

N7: Names Should Describe Side-Effects

Names should describe everything that a function, variable, or class is or does. Don’t hide side effects with a name. Don’t use a simple verb to describe a function that does more than just that simple action. For example, consider this code from TestNG:

public ObjectOutputStream getOos() throws IOException { if (m_oos == null) { m_oos = new ObjectOutputStream(m_socket.getOutputStream()); } return m_oos; }

This function does a bit more than get an “oos”; it creates the “oos” if it hasn’t been created already. Thus, a better name might be createOrReturnOos.

Tests

T1: Insufﬁcient Tests

How many tests should be in a test suite? Unfortunately, the metric many programmers use is “That seems like enough.” A test suite should test everything that could possibly break. The tests are insufﬁcient so long as there are conditions that have not been explored by the tests or calculations that have not been validated.

T2: Use a Coverage Tool!

Coverage tools reports gaps in your testing strategy. They make it easy to ﬁnd modules, classes, and functions that are insufﬁciently tested. Most IDEs give you a visual indication, marking lines that are covered in green and those that are uncovered in red. This makes it quick and easy to ﬁnd if or catch statements whose bodies haven’t been checked.

T3: Don’t Skip Trivial Tests

They are easy to write and their documentary value is higher than the cost to produce them.

T4: An Ignored Test Is a Question about an Ambiguity

Sometimes we are uncertain about a behavioral detail because the requirements are unclear. We can express our question about the requirements as a test that is commented out, or as a test that annotated with @Ignore. Which you choose depends upon whether the ambiguity is about something that would compile or not. 314

Chapter 17: Smells and Heuristics

T5: Test Boundary Conditions

Take special care to test boundary conditions. We often get the middle of an algorithm right but misjudge the boundaries.

T6: Exhaustively Test Near Bugs

Bugs tend to congregate. When you ﬁnd a bug in a function, it is wise to do an exhaustive test of that function. You’ll probably ﬁnd that the bug was not alone.

T7: Patterns of Failure Are Revealing

Sometimes you can diagnose a problem by ﬁnding patterns in the way the test cases fail. This is another argument for making the test cases as complete as possible. Complete test cases, ordered in a reasonable way, expose patterns.

As a simple example, suppose you noticed that all tests with an input larger than ﬁve characters failed? Or what if any test that passed a negative number into the second argument of a function failed? Sometimes just seeing the pattern of red and green on the test report is enough to spark the “Aha!” that leads to the solution. Look back at page 267 to see an interesting example of this in the SerialDate example.

T8: Test Coverage Patterns Can Be Revealing

Looking at the code that is or is not executed by the passing tests gives clues to why the failing tests fail.

T9: Tests Should Be Fast

A slow test is a test that won’t get run. When things get tight, it’s the slow tests that will be dropped from the suite. So do what you must to keep your tests fast.

Conclusion

This list of heuristics and smells could hardly be said to be complete. Indeed, I’m not sure that such a list can ever be complete. But perhaps completeness should not be the goal, because what this list does do is imply a value system.

Indeed, that value system has been the goal, and the topic, of this book. Clean code is not written by following a set of rules. You don’t become a software craftsman by learning a list of heuristics. Professionalism and craftsmanship come from values that drive disciplines. Bibliography

315

Bibliography

[Refactoring]: Refactoring: Improving the Design of Existing Code, Martin Fowler et al., Addison-Wesley, 1999.

[PRAG]: The Pragmatic Programmer, Andrew Hunt, Dave Thomas, Addison-Wesley, 2000.

[GOF]: Design Patterns: Elements of Reusable Object Oriented Software, Gamma et al., Addison-Wesley, 1996.

[Beck97]: Smalltalk Best Practice Patterns, Kent Beck, Prentice Hall, 1997.

[Beck07]: Implementation Patterns, Kent Beck, Addison-Wesley, 2008.

[PPP]: Agile Software Development: Principles, Patterns, and Practices, Robert C. Martin, Prentice Hall, 2002.

[DDD]: Domain Driven Design, Eric Evans, Addison-Wesley, 2003. This page intentionally left blank Appendix A

Concurrency II

by Brett L. Schuchert

This appendix supports and ampliﬁes the Concurrency chapter on page 177. It is written as a series of independent topics and you can generally read them in any order. There is some duplication between sections to allow for such reading.

Client/Server Example

Imagine a simple client/server application. A server sits and waits listening on a socket for a client to connect. A client connects and sends a request.

The Server

Here is a simpliﬁed version of a server application. Full source for this example is available starting on page 343, Client/Server Nonthreaded.

ServerSocket serverSocket = new ServerSocket(8009);

while (keepProcessing) { try { Socket socket = serverSocket.accept(); process(socket); } catch (Exception e) { handle(e); } }

317 318

Appendix A: Concurrency II

This simple application waits for a connection, processes an incoming message, and then again waits for the next client request to come in. Here’s client code that connects to this server:

private void connectSendReceive(int i) {

try { Socket socket = new Socket("localhost", PORT); MessageUtils.sendMessage(socket, Integer.toString(i)); MessageUtils.getMessage(socket); socket.close(); } catch (Exception e) { e.printStackTrace();

}

}

How well does this client/server pair perform? How can we formally describe that performance? Here’s a test that asserts that the performance is “acceptable”:

@Test(timeout = 10000) public void shouldRunInUnder10Seconds() throws Exception {

Thread[] threads = createThreads();

startAllThreadsw(threads);

waitForAllThreadsToFinish(threads); }

The setup is left out to keep the example simple (see “ClientTest.java” on page 344). This test asserts that it should complete within 10,000 milliseconds.

This is a classic example of validating the throughput of a system. This system should complete a series of client requests in ten seconds. So long as the server can process each individual client request in time, the test will pass.

What happens if the test fails? Short of developing some kind of event polling loop, there is not much to do within a single thread that will make this code any faster. Will using multiple threads solve the problem? It might, but we need to know where the time is being spent. There are two possibilities:

• I/O—using a socket, connecting to a database, waiting for virtual memory swapping, and so on.

• Processor—numerical calculations, regular expression processing, garbage collection, and so on.

Systems typically have some of each, but for a given operation one tends to dominate. If the code is processor bound, more processing hardware can improve throughput, making our test pass. But there are only so many CPU cycles available, so adding threads to a processor-bound problem will not make it go faster.

On the other hand, if the process is I/O bound, then concurrency can increase efﬁciency. When one part of the system is waiting for I/O, another part can use that wait time to process something else, making more effective use of the available CPU. Client/Server Example

319

Adding Threading

Assume for the moment that the performance test fails. How can we improve the throughput so that the performance test passes? If the process method of the server is I/O bound, then here is one way to make the server use threads (just change the processMessage):

void process(final Socket socket) { if (socket == null) return;

Runnable clientHandler = new Runnable() {

public void run() { try { String message = MessageUtils.getMessage(socket); MessageUtils.sendMessage(socket, "Processed: " + message); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); } }

};

Thread clientConnection = new Thread(clientHandler); clientConnection.start();

}

Assume that this change causes the test to pass; 1 the code is complete, correct?

Server Observations

The updated server completes the test successfully in just over one second. Unfortunately, this solution is a bit naive and introduces some new problems.

How many threads might our server create? The code sets no limit, so the we could feasibly hit the limit imposed by the Java Virtual Machine (JVM). For many simple systems this may sufﬁce. But what if the system is meant to support many users on the public net? If too many users connect at the same time, the system might grind to a halt.

But set the behavioral problem aside for the moment. The solution shown has problems of cleanliness and structure. How many responsibilities does the server code have?

• Socket connection management

• Client processing

• Threading policy

• Server shutdown policy

Unfortunately, all these responsibilities live in the process function. In addition, the code crosses many different levels of abstraction. So, small as the process function is, it needs to be repartitioned.

1. You can verify that for yourself by trying out the before and after code. Review the nonthreaded code starting on page 343.

Review the threaded code starting on page 346. 320

Appendix A: Concurrency II

The server has several reasons to change; therefore it violates the Single Responsibility Principle. To keep concurrent systems clean, thread management should be kept to a few, well-controlled places. What’s more, any code that manages threads should do nothing other than thread management. Why? If for no other reason than that tracking down concurrency issues is hard enough without having to unwind other nonconcurrency issues at the same time.

If we create a separate class for each of the responsibilities listed above, including the thread management responsibility, then when we change the thread management strategy, the change will impact less overall code and will not pollute the other responsibilities. This also makes it much easier to test all the other responsibilities without having to worry about threading. Here is an updated version that does just that:

public void run() {

while (keepProcessing) { try { ClientConnection clientConnection = connectionManager.awaitClient(); ClientRequestProcessor requestProcessor = new ClientRequestProcessor(clientConnection); clientScheduler.schedule(requestProcessor); } catch (Exception e) { e.printStackTrace(); }

} connectionManager.shutdown();

}

This now focuses all things thread-related into one place, clientScheduler. If there are concurrency problems, there is just one place to look:

public interface ClientScheduler { void schedule(ClientRequestProcessor requestProcessor); }

The current policy is easy to implement:

public class ThreadPerRequestScheduler implements ClientScheduler {

public void schedule(final ClientRequestProcessor requestProcessor) { Runnable runnable = new Runnable() { public void run() { requestProcessor.process(); } };

Thread thread = new Thread(runnable); thread.start();

}

}

Having isolated all the thread management into a single place, it is much easier to change the way we control threads. For example, moving to the Java 5 Executor framework involves writing a new class and plugging it in (Listing A-1). Possible Paths of Execution

321

Listing A-1 ExecutorClientScheduler.java

import java.util.concurrent.Executor; import java.util.concurrent.Executors;

public class ExecutorClientScheduler implements ClientScheduler { Executor executor;

public ExecutorClientScheduler(int availableThreads) { executor = Executors.newFixedThreadPool(availableThreads); }

public void schedule(final ClientRequestProcessor requestProcessor) { Runnable runnable = new Runnable() { public void run() { requestProcessor.process(); } }; executor.execute(runnable); }

}

Conclusion

Introducing concurrency in this particular example demonstrates a way to improve the throughput of a system and one way of validating that throughput through a testing framework. Focusing all concurrency code into a small number of classes is an example of applying the Single Responsibility Principle. In the case of concurrent programming, this becomes especially important because of its complexity.

Possible Paths of Execution

Review the method incrementValue, a one-line Java method with no looping or branching:

public class IdGenerator { int lastIdUsed;

public int incrementValue() { return ++lastIdUsed; }

}

Ignore integer overﬂow and assume that only one thread has access to a single instance of IdGenerator. In this case there is a single path of execution and a single guaranteed result:

• The value returned is equal to the value of lastIdUsed, both of which are one greater than just before calling the method. 322

Appendix A: Concurrency II

What happens if we use two threads and leave the method unchanged? What are the possible outcomes if each thread calls incrementValue once? How many possible paths of execution are there? First, the outcomes (assume lastIdUsed starts with a value of 93):

• Thread 1 gets the value of 94, thread 2 gets the value of 95, and lastIdUsed is now 95.

• Thread 1 gets the value of 95, thread 2 gets the value of 94, and lastIdUsed is now 95.

• Thread 1 gets the value of 94, thread 2 gets the value of 94, and lastIdUsed is now 94.

The ﬁnal result, while surprising, is possible. To see how these different results are possible, we need to understand the number of possible paths of execution and how the Java Virtual Machine executes them.

Number of Paths

To calculate the number of possible execution paths, we’ll start with the generated bytecode. The one line of java (return ++lastIdUsed;) becomes eight byte-code instructions. It is possible for the two threads to interleave the execution of these eight instructions the way a card dealer interleaves cards as he shufﬂes a deck. 2 Even with only eight cards in each hand, there are a remarkable number of shufﬂed outcomes.

For this simple case of N instructions in a sequence, no looping or conditionals, and T threads, the total number of possible execution paths is equal to

( NT )! -------------T N!

Calculating the Possible Orderings

This comes from an email from Uncle Bob to Brett:

With N steps and T threads there are T * N total steps. Prior to each step there is a context switch that chooses between the T threads. Each path can thus be represented as a string of digits denoting the context switches. Given steps A and B and threads 1 and 2, the six possible paths are 1122, 1212, 1221, 2112, 2121, and 2211. Or, in terms of steps it is A1B1A2B2, A1A2B1B2, A1A2B2B1, A2A1B1B2, A2A1B2B1, and A2B2A1B1. For three threads the sequence is 112233, 112323, 113223, 113232, 112233, 121233, 121323, 121332, 123132, 123123, . . . .

One characteristic of these strings is that there must always be N instances of each T. So the string 111111 is invalid because it has six instances of 1 and zero instances of 2 and 3.

2. This is a bit of a simpliﬁcation. However, for the purpose of this discussion, we can use this simplifying model. Possible Paths of Execution

323

Calculating the Possible Orderings (continued)

So we want the permutations of N 1’s, N 2’s, . . . and N T’s. This is really just the permutations of N * T things taken N * T at a time, which is (N * T )!, but with all the duplicates removed. So the trick is to count the duplicates and subtract that from (N * T )!.

Given two steps and two threads, how many duplicates are there? Each four-digit string has two 1s and two 2s. Each of those pairs could be swapped without changing the sense of the string. You could swap the 1s or the 2s both, or neither. So there are four isomorphs for each string, which means that there are three duplicates. So three out of four of the options are duplicates; alternatively one of four of the permutations are NOT duplicates. 4! * .25 = 6. So this reasoning seems to work.

How many duplicates are there? In the case where N = 2 and T = 2, I could swap the 1s, the 2s, or both. In the case where N = 2 and T = 3, I could swap the 1s, the 2s, the 3s, 1s and 2s, 1s and 3s, or 2s and 3s. Swapping is just the permutations of N. Let’s say there are P permutations of N. The number of different ways to arrange those permutations are P**T.

So the number of possible isomorphs is N!**T. And so the number of paths is (T*N)!/(N!**T). Again, in our T = 2, N = 2 case we get 6 (24/4).

For N = 2 and T = 3 we get 720/8 = 90.

For N = 3 and T = 3 we get 9!/6^3 = 1680.

For our simple case of one line of Java code, which equates to eight lines of byte-code and two threads, the total number of possible paths of execution is 12,870. If the type of lastIdUsed is a long, then every read/write becomes two operations instead of one, and the number of possible orderings becomes 2,704,156.

What happens if we make one change to this method?

public synchronized void incrementValue() { ++lastIdUsed; }

The number of possible execution pathways becomes two for two threads and N! in the general case.

Digging Deeper

What about the surprising result that two threads could both call the method once (before we added synchronized) and get the same numeric result? How is that possible? First things ﬁrst.

What is an atomic operation? We can deﬁne an atomic operation as any operation that is uninterruptable. For example, in the following code, line 5, where 0 is assigned to lastid, is atomic because according to the Java Memory model, assignment to a 32-bit value is uninterruptable. 324

Appendix A: Concurrency II

01: public class Example { 02: int lastId; 03:

04: public void resetId() { 05:

value

=

0;

06: } 07:

08: public int getNextId() { 09: ++value; 10: } 11:}

What happens if we change type of lastId from int to long? Is line 5 still atomic? Not according to the JVM speciﬁcation. It could be atomic on a particular processor, but according to the JVM speciﬁcation, assignment to any 64-bit value requires two 32-bit assignments. This means that between the ﬁrst 32-bit assignment and the second 32-bit assignment, some other thread could sneak in and change one of the values.

What about the pre-increment operator, ++, on line 9? The pre-increment operator can be interrupted, so it is not atomic. To understand, let’s review the byte-code of both of these methods in detail.

Before we go any further, here are three deﬁnitions that will be important:

• Frame—Every method invocation requires a frame. The frame includes the return address, any parameters passed into the method and the local variables deﬁned in the method. This is a standard technique used to deﬁne a call stack, which is used by modern languages to allow for basic function/method invocation and to allow for recursive invocation.

• Local variable—Any variables deﬁned in the scope of the method. All nonstatic methods have at least one variable, this, which represents the current object, the object that received the most recent message (in the current thread), which caused the method invocation.

• Operand stack—Many of the instructions in the Java Virtual Machine take parameters. The operand stack is where those parameters are put. The stack is a standard last-in, ﬁrst-out (LIFO) data structure.

Here is the byte-code generated for resetId():

Mnemonic

ALOAD 0

Description

Load the 0th variable onto the operand stack. What is the 0th variable? It is this., the current object. When the method was called, the receiver of the message, an instance of Example, was pushed into the local variable array of the frame created for method invocation. This is always the ﬁrst variable put in every instance method.

Operand Stack After

this Possible Paths of Execution

325

Mnemonic

ICONST_0 PUTFIELD lastId

Description

Put the constant value 0 onto the operand stack.

Store the top value on the stack (which is 0) into the ﬁeld value of the object referred to by the object reference one away from the top of the stack, this.

Operand Stack After

this, 0

<empty>

These three instructions are guaranteed to be atomic because, although the thread executing them could be interrupted after any one of them, the information for the PUTFIELD instruction (the constant value 0 on the top of the stack and the reference to this one below the top, along with the ﬁeld value) cannot be touched by another thread. So when the assignment occurs, we are guaranteed that the value 0 will be stored in the ﬁeld value. The operation is atomic. The operands all deal with information local to the method, so there is no interference between multiple threads.

So if these three instructions are executed by ten threads, there are 4.38679733629e+24 possible orderings. However, there is only one possible outcome, so the different orderings are irrelevant. It just so happens that the same outcome is guaranteed for longs in this case as well. Why? All ten threads are assigning a constant value. Even if they interleave with each other, the end result is the same.

With the ++ operation in the getNextId method, there are going to be problems. Assume that lastId holds 42 at the beginning of this method. Here is the byte-code for this new method:

Mnemonic

ALOAD 0 DUP

GETFIELD lastId

ICONST_1 IADD

DUP_X1 PUTFIELD value

IRETURN

Description

Load this onto the operand stack

Copy the top of the stack. We now have two copies of this on the operand stack.

Retrieve the value of the ﬁeld lastId from the object pointed to on the top of the stack (this) and store that value back on to the stack.

Push the integer constant 1 on the stack.

Integer add the top two values on the operand stack and store the result back on to the operand stack.

Duplicate the value 43 and put it before this.

Store the top value on the operand stack, 43, into the ﬁeld value of the current object, represented by the next-to-top value on the operand stack, this.

return the top (and only) value on the stack.

Operand Stack After

this this this

,

this, 42

this, 42, 1 this, 43

43, this, 43

43

<empty> 326

Appendix A: Concurrency II

Imagine the case where the ﬁrst thread completes the ﬁrst three instructions, up to and including GETFIELD, and then it is interrupted. A second thread takes over and performs the entire method, incrementing lastId by one; it gets 43 back. Then the ﬁrst thread picks up where it left off; 42 is still on the operand stack because that was the value of lastId when it executed GETFIELD. It adds one to get 43 again and stores the result. The value 43 is returned to the ﬁrst thread as well. The result is that one of the increments is lost because the ﬁrst thread stepped on the second thread after the second thread interrupted the ﬁrst thread.

Making the getNexId() method synchronized ﬁxes this problem.

Conclusion

An intimate understanding of byte-code is not necessary to understand how threads can step on each other. If you can understand this one example, it should demonstrate the possibility of multiple threads stepping on each other, which is enough knowledge.

That being said, what this trivial example demonstrates is a need to understand the memory model enough to know what is and is not safe. It is a common misconception that the ++ (pre- or post-increment) operator is atomic, and it clearly is not. This means you need to know:

• Where there are shared objects/values

• The code that can cause concurrent read/update issues

• How to guard such concurrent issues from happening

Knowing Your Library

Executor Framework

As demonstrated in the ExecutorClientScheduler.java on page 321, the Executor framework introduced in Java 5 allows for sophisticated execution using thread pools. This is a class in the java.util.concurrent package.

If you are creating threads and are not using a thread pool or are using a hand-written one, you should consider using the Executor. It will make your code cleaner, easier to follow, and smaller.

The Executor framework will pool threads, resize automatically, and recreate threads if necessary. It also supports futures, a common concurrent programming construct. The Executor framework works with classes that implement Runnable and also works with classes that implement the Callable interface. A Callable looks like a Runnable, but it can return a result, which is a common need in multithreaded solutions.

A future is handy when code needs to execute multiple, independent operations and wait for both to ﬁnish:

public String processRequest(String message) throws Exception {

Callable<String> makeExternalCall = new Callable<String>() { Knowing Your Library

327

public String call() throws Exception { String result = ""; // make external request return result; }

};

Future<String> result = executorService.submit(makeExternalCall); String partialResult = doSomeLocalProcessing(); return result.get() + partialResult;

}

In this example, the method starts executing the makeExternalCall object. The method continues other processing. The ﬁnal line calls result.get(), which blocks until the future completes.

Nonblocking Solutions

The Java 5 VM takes advantage of modern processor design, which supports reliable, nonblocking updates. Consider, for example, a class that uses synchronization (and therefore blocking) to provide a thread-safe update of a value:

public class ObjectWithValue { private int value; public void synchronized incrementValue() { ++value; } public int getValue() { return value; } }

Java 5 has a series of new classes for situations like this: AtomicBoolean, AtomicInteger, and AtomicReference are three examples; there are several more. We can rewrite the above code to use a nonblocking approach as follows:

public class ObjectWithValue { private AtomicInteger value = new AtomicInteger(0);

public void incrementValue() { value.incrementAndGet(); } public int getValue() {

return value.get(); }

}

Even though this uses an object instead of a primitive and sends messages like incrementAndGet() instead of ++, the performance of this class will nearly always beat the previous version. In some cases it will only be slightly faster, but the cases where it will be slower are virtually nonexistent.

How is this possible? Modern processors have an operation typically called Compare and Swap (CAS). This operation is analogous to optimistic locking in databases, whereas the synchronized version is analogous to pessimistic locking. 328

Appendix A: Concurrency II

The synchronized keyword always acquires a lock, even when a second thread is not trying to update the same value. Even though the performance of intrinsic locks has improved from version to version, they are still costly.

The nonblocking version starts with the assumption that multiple threads generally do not modify the same value often enough that a problem will arise. Instead, it efﬁciently detects whether such a situation has occurred and retries until the update happens successfully. This detection is almost always less costly than acquiring a lock, even in moderate to high contention situations.

How does the Virtual Machine accomplish this? The CAS operation is atomic. Logically, the CAS operation looks something like the following:

int variableBeingSet;

void simulateNonBlockingSet(int newValue) { int currentValue; do { currentValue = variableBeingSet } while(currentValue != compareAndSwap(currentValue, newValue)); }

int synchronized compareAndSwap(int currentValue, int newValue) { if(variableBeingSet == currentValue) { variableBeingSet = newValue; return currentValue; } return variableBeingSet; }

When a method attempts to update a shared variable, the CAS operation veriﬁes that the variable getting set still has the last known value. If so, then the variable is changed. If not, then the variable is not set because another thread managed to get in the way. The method making the attempt (using the CAS operation) sees that the change was not made and retries.

Nonthread-Safe Classes

There are some classes that are inherently not thread safe. Here are a few examples:

• SimpleDateFormat

• Database Connections

• Containers in java.util

• Servlets

Note that some collection classes have individual methods that are thread-safe. However, any operation that involves calling more than one method is not. For example, if you do not want to replace something in a HashTable because it is already there, you might write the following code:

if(!hashTable.containsKey(someKey)) { hashTable.put(someKey, new SomeValue()); } Dependencies Between Methods Can Break Concurrent Code

329

Each individual method is thread-safe. However, another thread might add a value in between the containsKey and put calls. There are several options to ﬁx this problem.

• Lock the HashTable ﬁrst, and make sure all other users of the HashTable do the sameclient-based locking:

synchronized(map) { if(!map.conainsKey(key)) map.put(key,value); }

• Wrap the HashTable in its own object and use a different API—server-based locking using an ADAPTER:

public class WrappedHashtable<K, V> {

private Map<K, V> map = new Hashtable<K, V>();

public synchronized void putIfAbsent(K key, V value) { if (map.containsKey(key)) map.put(key, value); }

}

• Use the thread-safe collections:

ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<Integer, String>(); map.putIfAbsent(key, value);

The collections in java.util.concurrent have operations like putIfAbsent() to accommodate such operations.

Dependencies Between Methods Can Break Concurrent Code

Here is a trivial example of a way to introduce dependencies between methods:

public class IntegerIterator implements Iterator<Integer> private Integer nextValue = 0;

public synchronized boolean hasNext() { return nextValue < 100000; } public synchronized Integer next() {

if (nextValue == 100000)

throw new IteratorPastEndException();

return nextValue++; } public synchronized Integer getNextValue() {

return nextValue; }

}

Here is some code to use this IntegerIterator:

IntegerIterator iterator = new IntegerIterator(); while(iterator.hasNext()) { 330

Appendix A: Concurrency II

int nextValue = iterator.next(); // do something with nextValue

}

If one thread executes this code, there will be no problem. But what happens if two threads attempt to share a single instance of IngeterIterator with the intent that each thread will process the values it gets, but that each element of the list is processed only once? Most of the time, nothing bad happens; the threads happily share the list, processing the elements they are given by the iterator and stopping when the iterator is complete. However, there is a small chance that, at the end of the iteration, the two threads will interfere with each other and cause one thread to go beyond the end of the iterator and throw an exception.

Here’s the problem: Thread 1 asks the question hasNext(), which returns true. Thread 1 gets preempted and then Thread 2 asks the same question, which is still true. Thread 2 then calls next(), which returns a value as expected but has a side effect of making hasNext() return false. Thread 1 starts up again, thinking hasNext() is still true, and then calls next(). Even though the individual methods are synchronized, the client uses two methods.

This is a real problem and an example of the kinds of problems that crop up in concurrent code. In this particular situation this problem is especially subtle because the only time where this causes a fault is when it happens during the ﬁnal iteration of the iterator. If the threads happen to break just right, then one of the threads could go beyond the end of the iterator. This is the kind of bug that happens long after a system has been in production, and it is hard to track down.

You have three options:

• Tolerate the failure.

• Solve the problem by changing the client: client-based locking

• Solve the problem by changing the server, which additionally changes the client:

server-based locking

Tolerate the Failure

Sometimes you can set things up such that the failure causes no harm. For example, the above client could catch the exception and clean up. Frankly, this is a bit sloppy. It’s rather like cleaning up memory leaks by rebooting at midnight.

Client-Based Locking

To make IntegerIterator work correctly with multiple threads, change this client (and every other client) as follows:

IntegerIterator iterator = new IntegerIterator();

while (true) { int nextValue; Dependencies Between Methods Can Break Concurrent Code

331

synchronized (iterator) { if (!iterator.hasNext()) break; nextValue = iterator.next(); } doSometingWith(nextValue);

}

Each client introduces a lock via the synchronized keyword. This duplication violates the DRY principle, but it might be necessary if the code uses non-thread-safe third-party tools.

This strategy is risky because all programmers who use the server must remember to lock it before using it and unlock it when done. Many (many!) years ago I worked on a system that employed client-based locking on a shared resource. The resource was used in hundreds of different places throughout the code. One poor programmer forgot to lock the resource in one of those places.

The system was a multi-terminal time-sharing system running accounting software for Local 705 of the trucker’s union. The computer was in a raised-ﬂoor, environmentcontrolled room 50 miles north of the Local 705 headquarters. At the headquarters they had dozens of data entry clerks typing union dues postings into the terminals. The terminals were connected to the computer using dedicated phone lines and 600bps half-duplex modems. (This was a very, very long time ago.)

About once per day, one of the terminals would “lock up.” There was no rhyme or reason to it. The lock up showed no preference for particular terminals or particular times. It was as though there were someone rolling dice choosing the time and terminal to lock up. Sometimes more than one terminal would lock up. Sometimes days would go by without any lock-ups.

At ﬁrst the only solution was a reboot. But reboots were tough to coordinate. We had to call the headquarters and get everyone to ﬁnish what they were doing on all the terminals. Then we could shut down and restart. If someone was doing something important that took an hour or two, the locked up terminal simply had to stay locked up.

After a few weeks of debugging we found that the cause was a ring-buffer counter that had gotten out of sync with its pointer. This buffer controlled output to the terminal. The pointer value indicated that the buffer was empty, but the counter said it was full. Because it was empty, there was nothing to display; but because it was also full, nothing could be added to the buffer to be displayed on the screen.

So we knew why the terminals were locking, but we didn’t know why the ring buffer was getting out of sync. So we added a hack to work around the problem. It was possible to read the front panel switches on the computer. (This was a very, very, very long time ago.) We wrote a little trap function that detected when one of these switches was thrown and then looked for a ring buffer that was both empty and full. If one was found, it reset that buffer to empty. Voila! The locked-up terminal(s) started displaying again.

So now we didn’t have to reboot the system when a terminal locked up. The Local would simply call us and tell us we had a lock-up, and then we just walked into the computer room and ﬂicked a switch. 332

Appendix A: Concurrency II

Of course sometimes they worked on the weekends, and we didn’t. So we added a function to the scheduler that checked all the ring buffers once per minute and reset any that were both empty and full. This caused the displays to unclog before the Local could even get on the phone.

It was several more weeks of poring over page after page of monolithic assembly language code before we found the culprit. We had done the math and calculated that the frequency of the lock-ups was consistent with a single unprotected use of the ring buffer. So all we had to do was ﬁnd that one faulty usage. Unfortunately, this was so very long ago that we didn’t have search tools or cross references or any other kind of automated help. We simply had to pore over listings.

I learned an important lesson that cold Chicago winter of 1971. Client-based locking really blows.

Server-Based Locking

The duplication can be removed by making the following changes to IntegerIterator:

public class IntegerIteratorServerLocked { private Integer nextValue = 0; public synchronized Integer getNextOrNull() { if (nextValue < 100000) return nextValue++; else return null; } }

And the client code changes as well:

while (true) { Integer nextValue = iterator.getNextOrNull(); if (next == null) break; // do something with nextValue }

In this case we actually change the API of our class to be multithread aware. 3 The client needs to perform a null check instead of checking hasNext().

In general you should prefer server-based locking for these reasons:

• It reduces repeated code—Client-based locking forces each client to lock the server properly. By putting the locking code into the server, clients are free to use the object and not worry about writing additional locking code.

3. In fact, the Iterator interface is inherently not thread-safe. It was never designed to be used by multiple threads, so this should come as no surprise. Increasing Throughput

333

• It allows for better performance—You can swap out a thread-safe server for a nonthread safe one in the case of single-threaded deployment, thereby avoiding all overhead.

• It reduces the possibility of error—All it takes is for one programmer to forget to lock properly.

• It enforces a single policy—The policy is in one place, the server, rather than many places, each client.

• It reduces the scope of the shared variables—The client is not aware of them or how they are locked. All of that is hidden in the server. When things break, the number of places to look is smaller.

What if you do not own the server code?

• Use an ADAPTER to change the API and add locking

public class ThreadSafeIntegerIterator { private IntegerIterator iterator = new IntegerIterator();

public synchronized Integer getNextOrNull() { if(iterator.hasNext()) return iterator.next(); return null; }

}

• OR better yet, use the thread-safe collections with extended interfaces

Increasing Throughput

Let’s assume that we want to go out on the net and read the contents of a set of pages from a list of URLs. As each page is read, we will parse it to accumulate some statistics. Once all the pages are read, we will print a summary report.

The following class returns the contents of one page, given a URL.

public class PageReader {

//...

public String getPageFor(String url) { HttpMethod method = new GetMethod(url);

try { httpClient.executeMethod(method); String response = method.getResponseBodyAsString(); return response; } catch (Exception e) { handle(e); } finally { method.releaseConnection(); }

}

} 334

Appendix A: Concurrency II

The next class is the iterator that provides the contents of the pages based on an iterator of URLs:

public class PageIterator {

private PageReader reader; private URLIterator urls;

public PageIterator(PageReader reader, URLIterator urls) { this.urls = urls; this.reader = reader; }

public synchronized String getNextPageOrNull() { if (urls.hasNext()) getPageFor(urls.next()); else return null; }

public String getPageFor(String url) { return reader.getPageFor(url); }

}

An instance of the PageIterator can be shared between many different threads, each one using it’s own instance of the PageReader to read and parse the pages it gets from the iterator.

Notice that we’ve kept the synchronized block very small. It contains just the critical section deep inside the PageIterator. It is always better to synchronize as little as possible as opposed to synchronizing as much as possible.

Single-Thread Calculation of Throughput

Now lets do some simple calculations. For the purpose of argument, assume the following:

• I/O time to retrieve a page (average): 1 second

• Processing time to parse page (average): .5 seconds

• I/O requires 0 percent of the CPU while processing requires 100 percent.

For N pages being processed by a single thread, the total execution time is 1.5 seconds * N. Figure A-1 shows a snapshot of 13 pages or about 19.5 seconds.

Figure A-1 Single thread Deadlock

335

Multithread Calculation of Throughput

If it is possible to retrieve pages in any order and process the pages independently, then it is possible to use multiple threads to increase throughput. What happens if we use three threads? How many pages can we acquire in the same time?

As you can see in Figure A-2, the multithreaded solution allows the process-bound parsing of the pages to overlap with the I/O-bound reading of the pages. In an idealized world this means that the processor is fully utilized. Each one-second page read is overlapped with two parses. Thus, we can process two pages per second, which is three times the throughput of the single-threaded solution.

Figure A-2 Three concurrent threads

Deadlock

Imagine a Web application with two shared resource pools of some ﬁnite size:

• A pool of database connections for local work in process storage

• A pool of MQ connections to a master repository

Assume there are two operations in this application, create and update:

• Create—Acquire connection to master repository and database. Talk to service master repository and then store work in local work in process database. 336

Appendix A: Concurrency II

• Update—Acquire connection to database and then master repository. Read from work in process database and then send to the master repository

What happens when there are more users than the pool sizes? Consider each pool has a size of ten.

• Ten users attempt to use create, so all ten database connections are acquired, and each thread is interrupted after acquiring a database connection but before acquiring a connection to the master repository.

• Ten users attempt to use update, so all ten master repository connections are acquired, and each thread is interrupted after acquiring the master repository but before acquiring a database connection.

• Now the ten “create” threads must wait to acquire a master repository connection, but the ten “update” threads must wait to acquire a database connection.

• Deadlock. The system never recovers.

This might sound like an unlikely situation, but who wants a system that freezes solid every other week? Who wants to debug a system with symptoms that are so difﬁcult to reproduce? This is the kind of problem that happens in the ﬁeld, then takes weeks to solve.

A typical “solution” is to introduce debugging statements to ﬁnd out what is happening. Of course, the debug statements change the code enough so that the deadlock happens in a different situation and takes months to again occur.4 

To really solve the problem of deadlock, we need to understand what causes it. There are four conditions required for deadlock to occur:

• Mutual exclusion

• Lock & wait

• No preemption

• Circular wait

Mutual Exclusion

Mutual exclusion occurs when multiple threads need to use the same resources and those resources

• Cannot be used by multiple threads at the same time.

• Are limited in number.

A common example of such a resource is a database connection, a ﬁle open for write, a record lock, or a semaphore.

4. For example, someone adds some debugging output and the problem “disappears.” The debugging code “ﬁxes” the problem so it remains in the system. Deadlock

337

Lock & Wait

Once a thread acquires a resource, it will not release the resource until it has acquired all of the other resources it requires and has completed its work.

No Preemption

One thread cannot take resources away from another thread. Once a thread holds a resource, the only way for another thread to get it is for the holding thread to release it.

Circular Wait

This is also referred to as the deadly embrace. Imagine two threads, T1 and T2, and two resources, R1 and R2. T1 has R1, T2 has R2. T1 also requires R2, and T2 also requires R1. This gives something like Figure A-3:

Figure A-3

All four of these conditions must hold for deadlock to be possible. Break any one of these conditions and deadlock is not possible.

Breaking Mutual Exclusion

One strategy for avoiding deadlock is to sidestep the mutual exclusion condition. You might be able to do this by

• Using resources that allow simultaneous use, for example, AtomicInteger.

• Increasing the number of resources such that it equals or exceeds the number of competing threads.

• Checking that all your resources are free before seizing any.

Unfortunately, most resources are limited in number and don’t allow simultaneous use. And it’s not uncommon for the identity of the second resource to be predicated on the results of operating on the ﬁrst. But don’t be discouraged; there are three conditions left. 338

Appendix A: Concurrency II

Breaking Lock & Wait

You can also eliminate deadlock if you refuse to wait. Check each resource before you seize it, and release all resources and start over if you run into one that’s busy.

This approach introduces several potential problems:

• Starvation—One thread keeps being unable to acquire the resources it needs (maybe it has a unique combination of resources that seldom all become available).

• Livelock—Several threads might get into lockstep and all acquire one resource and then release one resource, over and over again. This is especially likely with simplistic CPU scheduling algorithms (think embedded devices or simplistic hand-written thread balancing algorithms).

Both of these can cause poor throughput. The ﬁrst results in low CPU utilization, whereas the second results in high and useless CPU utilization.

As inefﬁcient as this strategy sounds, it’s better than nothing. It has the beneﬁt that it can almost always be implemented if all else fails.

Breaking Preemption

Another strategy for avoiding deadlock is to allow threads to take resources away from other threads. This is usually done through a simple request mechanism. When a thread discovers that a resource is busy, it asks the owner to release it. If the owner is also waiting for some other resource, it releases them all and starts over.

This is similar to the previous approach but has the beneﬁt that a thread is allowed to wait for a resource. This decreases the number of startovers. Be warned, however, that managing all those requests can be tricky.

Breaking Circular Wait

This is the most common approach to preventing deadlock. For most systems it requires no more than a simple convention agreed to by all parties.

In the example above with Thread 1 wanting both Resource 1 and Resource 2 and Thread 2 wanting both Resource 2 and then Resource 1, simply forcing both Thread 1 and Thread 2 to allocate resources in the same order makes circular wait impossible.

More generally, if all threads can agree on a global ordering of resources and if they all allocate resources in that order, then deadlock is impossible. Like all the other strategies, this can cause problems:

• The order of acquisition might not correspond to the order of use; thus a resource acquired at the start might not be used until the end. This can cause resources to be locked longer than strictly necessary. Testing Multithreaded Code

339

• Sometimes you cannot impose an order on the acquisition of resources. If the ID of the second resource comes from an operation performed on the ﬁrst, then ordering is not feasible.

So there are many ways to avoid deadlock. Some lead to starvation, whereas others make heavy use of the CPU and reduce responsiveness. TANSTAAFL! 5

Isolating the thread-related part of your solution to allow for tuning and experimentation is a powerful way to gain the insights needed to determine the best strategies.

Testing Multithreaded Code

How can we write a test to demonstrate the following code is broken?

01: public class ClassWithThreadingProblem { 02: int nextId; 03:

04: public int takeNextId() { 05: return nextId++; 06: } 07:}

Here’s a description of a test that will prove the code is broken:

• Remember the current value of nextId.

• Create two threads, both of which call takeNextId() once.

• Verify that nextId is two more than what we started with.

• Run this until we demonstrate that nextId was only incremented by one instead of two.

Listing A-2 shows such a test:

Listing A-2 ClassWithThreadingProblemTest.java

01: package example; 02:

03: import static org.junit.Assert.fail; 04:

05: import org.junit.Test; 06:

07: public class ClassWithThreadingProblemTest { 08: @Test 09: public void twoThreadsShouldFailEventually() throws Exception { 10: final ClassWithThreadingProblem classWithThreadingProblem = new ClassWithThreadingProblem(); 11:

5. There ain’t no such thing as a free lunch. 340

Appendix A: Concurrency II

Listing A-2 (continued) ClassWithThreadingProblemTest.java

12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: 35: 36: 37: }

Runnable runnable = new Runnable() { public void run() { classWithThreadingProblem.takeNextId(); } };

for

}

(int

i

=

0;

i

<

50000;

++i)

{

int startingId = classWithThreadingProblem.lastId; int expectedResult = 2 + startingId;

Thread t1 = new Thread(runnable); Thread t2 = new Thread(runnable); t1.start(); t2.start(); t1.join(); t2.join();

int endingId = classWithThreadingProblem.lastId;

if (endingId != expectedResult) return;

fail("Should have exposed a threading issue but it did not.");

}

Line

10

12–16

18

19

20

22–23

Description Create a single instance of ClassWithThreadingProblem. Note, we must use the ﬁnal keyword because we use it below in an anonymous inner class.

Create an anonymous inner class that uses the single instance of ClassWithThreadingProblem.

Run this code “enough” times to demonstrate that the code failed, but not so much that the test “takes too long.” This is a balancing act; we don’t want to wait too long to demonstrate failure. Picking this number is hardalthough later we’ll see that we can greatly reduce this number.

Remember the starting value. This test is trying to prove that the code in ClassWithThreadingProblem is broken. If this test passes, it proved that the code was broken. If this test fails, the test was unable to prove that the code is broken.

We expect the ﬁnal value to be two more than the current value.

Create two threads, both of which use the object we created in lines 12–16. This gives us the potential of two threads trying to use our single instance of ClassWithThreadingProblem and interfering with each other. Testing Multithreaded Code

341

Line

24–25 26–27 29 31–32

35

Description Make our two threads eligible to run.

Wait for both threads to ﬁnish before we check the results.

Record the actual ﬁnal value.

Did our endingId differ from what we expected? If so, return end the testwe’ve proven that the code is broken. If not, try again.

If we got to here, our test was unable to prove the production code was broken in a “reasonable” amount of time; our code has failed. Either the code is not broken or we didn’t run enough iterations to get the failure condition to occur.

This test certainly sets up the conditions for a concurrent update problem. However, the problem occurs so infrequently that the vast majority of times this test won’t detect it.

Indeed, to truly detect the problem we need to set the number of iterations to over one million. Even then, in ten executions with a loop count of 1,000,000, the problem occurred only once. That means we probably ought to set the iteration count to well over one hundred million to get reliable failures. How long are we prepared to wait?

Even if we tuned the test to get reliable failures on one machine, we’ll probably have to retune the test with different values to demonstrate the failure on another machine, operating system, or version of the JVM.

And this is a simple problem. If we cannot demonstrate broken code easily with this problem, how will we ever detect truly complex problems?

So what approaches can we take to demonstrate this simple failure? And, more importantly, how can we write tests that will demonstrate failures in more complex code? How will we be able to discover if our code has failures when we do not know where to look?

Here are a few ideas:

• Monte Carlo Testing. Make tests ﬂexible, so they can be tuned. Then run the test over and over—say on a test server—randomly changing the tuning values. If the tests ever fail, the code is broken. Make sure to start writing those tests early so a continuous integration server starts running them soon. By the way, make sure you carefully log the conditions under which the test failed.

• Run the test on every one of the target deployment platforms. Repeatedly. Continuously. The longer the tests run without failure, the more likely that

– The production code is correct or

– The tests aren’t adequate to expose problems.

• Run the tests on a machine with varying loads. If you can simulate loads close to a production environment, do so. 342

Appendix A: Concurrency II

Yet, even if you do all of these things, you still don’t stand a very good chance of ﬁnding threading problems with your code. The most insidious problems are the ones that have such a small cross section that they only occur once in a billion opportunities. Such problems are the terror of complex systems.

Tool Support for Testing Thread-Based Code

IBM has created a tool called ConTest. 6 It instruments classes to make it more likely that non-thread-safe code fails.

We do not have any direct relationship with IBM or the team that developed ConTest. A colleague of ours pointed us to it. We noticed vast improvement in our ability to ﬁnd threading issues after a few minutes of using it.

Here’s an outline of how to use ConTest:

• Write tests and production code, making sure there are tests speciﬁcally designed to simulate multiple users under varying loads, as mentioned above.

• Instrument test and production code with ConTest.

• Run the tests.

When we instrumented code with ConTest, our success rate went from roughly one failure in ten million iterations to roughly one failure in thirty iterations. Here are the loop values for several runs of the test after instrumentation: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. So clearly the instrumented classes failed much earlier and with much greater reliability.

Conclusion

This chapter has been a very brief sojourn through the large and treacherous territory of concurrent programming. We barely scratched the surface. Our emphasis here was on disciplines to help keep concurrent code clean, but there is much more you should learn if you are going to be writing concurrent systems. We recommend you start with Doug Lea’s wonderful book Concurrent Programming in Java: Design Principles and Patterns.7 

In this chapter we talked about concurrent update, and the disciplines of clean synchronization and locking that can prevent it. We talked about how threads can enhance the throughput of an I/O-bound system and showed the clean techniques for achieving such improvements. We talked about deadlock and the disciplines for preventing it in a clean

6. http://www.haifa.ibm.com/projects/veriﬁcation/contest/index.html

7. See [Lea99] p. 191. Tutorial: Full Code Examples

343

way. Finally, we talked about strategies for exposing concurrent problems by instrumenting your code.

Tutorial: Full Code Examples

Client/Server Nonthreaded

Listing A-3 Server.java

package com.objectmentor.clientserver.nonthreaded;

import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException;

import common.MessageUtils;

public class Server implements Runnable {

ServerSocket serverSocket; volatile boolean keepProcessing = true;

public Server(int port, int millisecondsTimeout) throws IOException { serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(millisecondsTimeout); }

public void run() { System.out.printf("Server Starting\n");

while (keepProcessing) { try { System.out.printf("accepting client\n"); Socket socket = serverSocket.accept(); System.out.printf("got client\n"); process(socket); } catch (Exception e) { handle(e); } }

}

private void handle(Exception e) { if (!(e instanceof SocketException)) { e.printStackTrace(); } }

public void stopProcessing() { keepProcessing = false; closeIgnoringException(serverSocket); } 344

Appendix A: Concurrency II

Listing A-3 (continued) Server.java

void process(Socket socket) { if (socket == null) return;

try { System.out.printf("Server: getting message\n"); String message = MessageUtils.getMessage(socket); System.out.printf("Server: got message: %s\n", message); Thread.sleep(1000); System.out.printf("Server: sending reply: %s\n", message); MessageUtils.sendMessage(socket, "Processed: " + message); System.out.printf("Server: sent\n"); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); }

}

private void closeIgnoringException(Socket socket) { if (socket != null) try { socket.close(); } catch (IOException ignore) { } }

private void closeIgnoringException(ServerSocket serverSocket) { if (serverSocket != null) try { serverSocket.close(); } catch (IOException ignore) { } }

}

Listing A-4 ClientTest.java

package com.objectmentor.clientserver.nonthreaded;

import java.io.IOException; import java.net.ServerSocket; import java.net.Socket; import java.net.SocketException;

import common.MessageUtils;

public class Server implements Runnable {

ServerSocket serverSocket; volatile boolean keepProcessing = true; Tutorial: Full Code Examples

345

Listing A-4 (continued) ClientTest.java

public Server(int port, int millisecondsTimeout) throws IOException { serverSocket = new ServerSocket(port); serverSocket.setSoTimeout(millisecondsTimeout); }

public void run() { System.out.printf("Server Starting\n");

while (keepProcessing) { try { System.out.printf("accepting client\n"); Socket socket = serverSocket.accept(); System.out.printf("got client\n"); process(socket); } catch (Exception e) { handle(e); } }

}

private void handle(Exception e) { if (!(e instanceof SocketException)) { e.printStackTrace(); } }

public void stopProcessing() { keepProcessing = false; closeIgnoringException(serverSocket); }

void process(Socket socket) { if (socket == null) return;

try { System.out.printf("Server: getting message\n"); String message = MessageUtils.getMessage(socket); System.out.printf("Server: got message: %s\n", message); Thread.sleep(1000); System.out.printf("Server: sending reply: %s\n", message); MessageUtils.sendMessage(socket, "Processed: " + message); System.out.printf("Server: sent\n"); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); }

}

private void closeIgnoringException(Socket socket) { if (socket != null) try { socket.close(); 346

Appendix A: Concurrency II

Listing A-4 (continued) ClientTest.java

} catch (IOException ignore) { }

}

private void closeIgnoringException(ServerSocket serverSocket) { if (serverSocket != null) try { serverSocket.close(); } catch (IOException ignore) { } }

}

Listing A-5 MessageUtils.java

package common;

import java.io.IOException; import java.io.InputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.net.Socket;

public class MessageUtils {

public static void sendMessage(Socket socket, String message) throws IOException { OutputStream stream = socket.getOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(stream); oos.writeUTF(message); oos.flush(); }

public static String getMessage(Socket socket) throws IOException { InputStream stream = socket.getInputStream(); ObjectInputStream ois = new ObjectInputStream(stream); return ois.readUTF(); }

}

Client/Server Using Threads

Changing the server to use threads simply requires a change to the process message (new lines are emphasized to stand out):

void process(final Socket socket) { if (socket == null) return;

Runnable clientHandler = new Runnable() { public void run() { Tutorial: Full Code Examples

347

try { System.out.printf("Server: getting message\n"); String message = MessageUtils.getMessage(socket); System.out.printf("Server: got message: %s\n", message); Thread.sleep(1000); System.out.printf("Server: sending reply: %s\n", message); MessageUtils.sendMessage(socket, "Processed: " + message); System.out.printf("Server: sent\n"); closeIgnoringException(socket); } catch (Exception e) { e.printStackTrace(); }

}

};

Thread clientConnection = new Thread(clientHandler); clientConnection.start();

} This page intentionally left blank Appendix B

org.jfree.date.SerialDate

Listing B-1 SerialDate.Java

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

* * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

* * Project Info: http://www.jfree.org/jcommon/index.html * * This library is free software; you can redistribute it and/or modify it * under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation; either version 2.1 of the License, or * (at your option) any later version.

* * This library is distributed in the hope that it will be useful, but * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public * License for more details.

* * You should have received a copy of the GNU Lesser General Public * License along with this library; if not, write to the Free Software * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, * USA.

* * [Java is a trademark or registered trademark of Sun Microsystems, Inc.

* in the United States and other countries.] * * --------------* SerialDate.java * --------------* (C) Copyright 2001-2005, by Object Refinery Limited.

* * Original Author: David Gilbert (for Object Refinery Limited); * Contributor(s): -; * * $Id: SerialDate.java,v 1.7 2005/11/03 09:25:17 mungady Exp $ * * Changes (from 11-Oct-2001)

349 350

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

38 * -------------------------39 * 11-Oct-2001 : Re-organised the class and moved it to new package 40 * com.jrefinery.date (DG); 41 * 05-Nov-2001 : Added a getDescription() method, and eliminated NotableDate 42 * class (DG); 43 * 12-Nov-2001 : IBD requires setDescription() method, now that NotableDate 44 * class is gone (DG); Changed getPreviousDayOfWeek(), 45 * getFollowingDayOfWeek() and getNearestDayOfWeek() to correct 46 * bugs (DG); 47 * 05-Dec-2001 : Fixed bug in SpreadsheetDate class (DG); 48 * 29-May-2002 : Moved the month constants into a separate interface 49 * (MonthConstants) (DG); 50 * 27-Aug-2002 : Fixed bug in addMonths() method, thanks to N???levka Petr (DG); 51 * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG); 52 * 13-Mar-2003 : Implemented Serializable (DG); 53 * 29-May-2003 : Fixed bug in addMonths method (DG); 54 * 04-Sep-2003 : Implemented Comparable. Updated the isInRange javadocs (DG); 55 * 05-Jan-2005 : Fixed bug in addYears() method (1096282) (DG); 56 * 57 */ 58 59 package org.jfree.date; 60 61 import java.io.Serializable; 62 import java.text.DateFormatSymbols; 63 import java.text.SimpleDateFormat; 64 import java.util.Calendar; 65 import java.util.GregorianCalendar; 66 67 /** 68 * An abstract class that defines our requirements for manipulating dates, 69 * without tying down a particular implementation.

70 * <P> 71 * Requirement 1 : match at least what Excel does for dates; 72 * Requirement 2 : class is immutable; 73 * <P> 74 * Why not just use java.util.Date? We will, when it makes sense. At times, 75 * java.util.Date can be *too* precise - it represents an instant in time, 76 * accurate to 1/1000th of a second (with the date itself depending on the 77 * time-zone). Sometimes we just want to represent a particular day (e.g. 21 78 * January 2015) without concerning ourselves about the time of day, or the 79 * time-zone, or anything else. That's what we've defined SerialDate for.

80 * <P> 81 * You can call getInstance() to get a concrete subclass of SerialDate, 82 * without worrying about the exact implementation.

83 * 84 * @author David Gilbert 85 */ 86 public abstract class SerialDate implements Comparable, 87 Serializable, 88 MonthConstants { 89 90 /** For serialization. */ 91 private static final long serialVersionUID = -293716040467423637L; 92 93 /** Date format symbols. */ 94 public static final DateFormatSymbols 95 DATE_FORMAT_SYMBOLS = new SimpleDateFormat().getDateFormatSymbols(); 96 97 /** The serial number for 1 January 1900. */ 98 public static final int SERIAL_LOWER_BOUND = 2; 99 100 /** The serial number for 31 December 9999. */ 101 public static final int SERIAL_UPPER_BOUND = 2958465; 102 Appendix B: org.jfree.date.SerialDate

351

Listing B-1 (continued) SerialDate.Java

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

/** The lowest year value supported by this date format. */ public static final int MINIMUM_YEAR_SUPPORTED = 1900;

/** The highest year value supported by this date format. */ public static final int MAXIMUM_YEAR_SUPPORTED = 9999;

/** Useful constant for Monday. Equivalent to java.util.Calendar.MONDAY. */ public static final int MONDAY = Calendar.MONDAY;

/** * Useful constant for Tuesday. Equivalent to java.util.Calendar.TUESDAY. */ public static final int TUESDAY = Calendar.TUESDAY;

/** * Useful constant for Wednesday. Equivalent to * java.util.Calendar.WEDNESDAY.

*/ public static final int WEDNESDAY = Calendar.WEDNESDAY;

/** * Useful constant for Thrusday. Equivalent to java.util.Calendar.THURSDAY. */ public static final int THURSDAY = Calendar.THURSDAY;

/** Useful constant for Friday. Equivalent to java.util.Calendar.FRIDAY. */ public static final int FRIDAY = Calendar.FRIDAY;

/** * Useful constant for Saturday. Equivalent to java.util.Calendar.SATURDAY. */ public static final int SATURDAY = Calendar.SATURDAY;

/** Useful constant for Sunday. Equivalent to java.util.Calendar.SUNDAY. */ public static final int SUNDAY = Calendar.SUNDAY;

/** The number of days in each month in non leap years. */ static final int[] LAST_DAY_OF_MONTH = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

/** The number of days in a (non-leap) year up to the end of each month. */ static final int[] AGGREGATE_DAYS_TO_END_OF_MONTH = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

/** The number of days in a year up to the end of the preceding month. */ static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH = {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};

/** The number of days in a leap year up to the end of each month. */ static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH = {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};

/** * The number of days in a leap year up to the end of the preceding month. */ static final int[]

LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =

{0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};

/** A useful constant for referring to the first week in a month. */ public static final int FIRST_WEEK_IN_MONTH = 1; 352

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

165

166

167

168

169

170

171

172

173

174

175

176

177

178

179

180

181

182

183

184

185

186

187

188

189

190

191

192

193

194

195

196

197

198

199

200

201

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218

219

220

221

222

223

224

225

226

/** A useful constant for referring to the second week in a month. */ public static final int SECOND_WEEK_IN_MONTH = 2;

/** A useful constant for referring to the third week in a month. */ public static final int THIRD_WEEK_IN_MONTH = 3;

/** A useful constant for referring to the fourth week in a month. */ public static final int FOURTH_WEEK_IN_MONTH = 4;

/** A useful constant for referring to the last week in a month. */ public static final int LAST_WEEK_IN_MONTH = 0;

/** Useful range constant. */ public static final int INCLUDE_NONE = 0;

/** Useful range constant. */ public static final int INCLUDE_FIRST = 1;

/** Useful range constant. */ public static final int INCLUDE_SECOND = 2;

/** Useful range constant. */ public static final int INCLUDE_BOTH = 3;

/** * Useful constant for specifying a day of the week relative to a fixed * date.

*/ public static final int PRECEDING = -1;

/** * Useful constant for specifying a day of the week relative to a fixed * date.

*/ public static final int NEAREST = 0;

/** * Useful constant for specifying a day of the week relative to a fixed * date.

*/ public static final int FOLLOWING = 1;

/** A description for the date. */ private String description;

/** * Default constructor. */ protected SerialDate() { }

/** * Returns <code>true</code> if the supplied integer code represents a * valid day-of-the-week, and <code>false</code> otherwise.

* * @param code the code being checked for validity.

* * @return <code>true</code> if the supplied integer code represents a * valid day-of-the-week, and <code>false</code> otherwise. */ public static boolean isValidWeekdayCode(final int code) { Appendix B: org.jfree.date.SerialDate

353

Listing B-1 (continued) SerialDate.Java

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

245

246

247

248

249

250

251

252

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277

278

279

280

281

282

283

284

285

286

287

switch(code) {

case SUNDAY: case MONDAY: case TUESDAY: case WEDNESDAY: case THURSDAY: case FRIDAY: case SATURDAY:

return true; default:

return false;

}

}

/** * Converts the supplied string to a day of the week.

* * @param s a string representing the day of the week.

* * @return <code>-1</code> if the string is not convertable, the day of * the week otherwise.

*/ public static int stringToWeekdayCode(String s) {

final String[] shortWeekdayNames = DATE_FORMAT_SYMBOLS.getShortWeekdays(); final String[] weekDayNames = DATE_FORMAT_SYMBOLS.getWeekdays();

int result = -1; s = s.trim(); for (int i = 0; i < weekDayNames.length; i++) { if (s.equals(shortWeekdayNames[i])) { result = i; break; } if (s.equals(weekDayNames[i])) { result = i; break; } } return result;

}

/** * Returns a string representing the supplied day-of-the-week. * <P> * Need to find a better approach.

* * @param weekday the day of the week.

* * @return a string representing the supplied day-of-the-week. */ public static String weekdayCodeToString(final int weekday) {

final String[] weekdays = DATE_FORMAT_SYMBOLS.getWeekdays(); return weekdays[weekday];

}

288

/** 354

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

307

308

309

310

311

312

313

314

315

316

317

318

319

320

321

322

323

324

325

326

327

328

329

330

331

332

333

334

335

336

337

338

339

340

341

342

343

344

345

346

347

348

349

350

* Returns an array of month names. * * @return an array of month names. */ public static String[] getMonths() {

return getMonths(false);

}

/** * Returns an array of month names.

* * @param shortened a flag indicating that shortened month names should * be returned.

* * @return an array of month names.

*/ public static String[] getMonths(final boolean shortened) {

if (shortened) { return DATE_FORMAT_SYMBOLS.getShortMonths(); } else {

return DATE_FORMAT_SYMBOLS.getMonths(); }

}

/** * Returns true if the supplied integer code represents a valid month. * * @param code the code being checked for validity.

* * @return <code>true</code> if the supplied integer code represents a * valid month.

*/ public static boolean isValidMonthCode(final int code) {

switch(code) {

case JANUARY: case FEBRUARY: case MARCH: case APRIL: case MAY:

case JUNE: case JULY: case AUGUST: case SEPTEMBER: case OCTOBER: case NOVEMBER: case DECEMBER:

return true; default:

return false;

}

}

/**

* Returns the quarter for the specified month. * Appendix B: org.jfree.date.SerialDate

355

Listing B-1 (continued) SerialDate.Java

351

352

353

354

355

356

357

358

359

360

361

362

363

364

365

366

367

368

369

370

371

372

373

374

375

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392

393

394

395

396

397

398

399

400

401

402

403

404

405

406

407

408

409

410

411

412

* @param code the month code (1-12).

* * @return the quarter that the month belongs to.

* @throws java.lang.IllegalArgumentException */ public static int monthCodeToQuarter(final int code) {

switch(code) {

case JANUARY:

case FEBRUARY:

case MARCH: return 1; case APRIL:

case MAY:

case JUNE: return 2; case JULY:

case AUGUST:

case SEPTEMBER: return 3; case OCTOBER:

case NOVEMBER:

case DECEMBER: return 4; default: throw new IllegalArgumentException( "SerialDate.monthCodeToQuarter: invalid month code.");

}

}

/** * Returns a string representing the supplied month.

* <P> * The string returned is the long form of the month name taken from the * default locale.

* * @param month the month.

* * @return a string representing the supplied month.

*/ public static String monthCodeToString(final int month) {

return monthCodeToString(month, false);

}

/** * Returns a string representing the supplied month.

* <P> * The string returned is the long or short form of the month name taken * from the default locale.

* * @param month the month.

* @param shortened if <code>true</code> return the abbreviation of the * month.

* * @return a string representing the supplied month.

* @throws java.lang.IllegalArgumentException */ public static String monthCodeToString(final int month, final boolean shortened) {

// check arguments...

if (!isValidMonthCode(month)) {

throw new IllegalArgumentException( "SerialDate.monthCodeToString: month outside valid range."); 356

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

413

414

415

416

417

418

419

420

421

422

423

424

425

426

427

428

429

430

431

432

433

434

435

436

437

438

439

440

441

442

443

444

445

446

447

448

449

450

451

452

453

454

455

456

457

458

459

460

461

462

463

464

465

466

467

468

469

470

471

472

473

}

final String[] months;

if (shortened) { months = DATE_FORMAT_SYMBOLS.getShortMonths(); } else {

months = DATE_FORMAT_SYMBOLS.getMonths(); }

return months[month - 1];

}

/** * Converts a string to a month code.

* <P> * This method will return one of the constants JANUARY, FEBRUARY, ..., * DECEMBER that corresponds to the string. If the string is not * recognised, this method returns -1.

* * @param s the string to parse.

* * @return <code>-1</code> if the string is not parseable, the month of the * year otherwise.

*/ public static int stringToMonthCode(String s) {

final String[] shortMonthNames = DATE_FORMAT_SYMBOLS.getShortMonths(); final String[] monthNames = DATE_FORMAT_SYMBOLS.getMonths();

int result = -1; s = s.trim();

// first try parsing the string as an integer (1-12)... try {

result = Integer.parseInt(s); } catch (NumberFormatException e) {

// suppress }

// now search through the month names... if ((result < 1) || (result > 12)) {

for

}

(int

i

=

0;

i

<

monthNames.length;

i++)

{

if (s.equals(shortMonthNames[i])) {

result

break;

=

i

+

1;

} if (s.equals(monthNames[i])) {

result

break;

=

i

+

1;

}

}

return result;

}

474

/** Appendix B: org.jfree.date.SerialDate

357

Listing B-1 (continued) SerialDate.Java

475

476

477

478

479

480

481

482

483

484

485

486

487

488

489

490

491

492

493

494

495

496

497

498

499

500

501

502

503

504

505

506

507

508

509

510

511

512

513

514

515

516

517

518

519

520

521

522

523

524

525

526

527

528

529

530

531

532

533

534

535

* Returns true if the supplied integer code represents a valid * week-in-the-month, and false otherwise.

* * @param code the code being checked for validity.

* @return <code>true</code> if the supplied integer code represents a * valid week-in-the-month.

*/ public static boolean isValidWeekInMonthCode(final int code) {

switch(code) { case FIRST_WEEK_IN_MONTH:

case SECOND_WEEK_IN_MONTH:

case THIRD_WEEK_IN_MONTH:

case FOURTH_WEEK_IN_MONTH:

case LAST_WEEK_IN_MONTH: return true; default: return false; }

}

/** * Determines whether or not the specified year is a leap year.

* * @param yyyy the year (in the range 1900 to 9999).

* * @return <code>true</code> if the specified year is a leap year. */ public static boolean isLeapYear(final int yyyy) {

if ((yyyy % 4) != 0) { return false; } else if ((yyyy % 400) == 0) {

return true; } else if ((yyyy % 100) == 0) {

return false; } else {

return true; }

}

/** * Returns the number of leap years from 1900 to the specified year * INCLUSIVE.

* <P> * Note that 1900 is not a leap year.

* * @param yyyy the year (in the range 1900 to 9999).

* * @return the number of leap years from 1900 to the specified year. */ public static int leapYearCount(final int yyyy) {

final int leap4 = (yyyy - 1896) / 4; final int leap100 = (yyyy - 1800) / 100; final int leap400 = (yyyy - 1600) / 400; return leap4 - leap100 + leap400;

536

} 358

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

537

538

539

540

541

542

543

544

545

546

547

548

549

550

551

552

553

554

555

556

557

558

559

560

561

562

563

564

565

566

567

568

569

570

571

572

573

574

575

576

577

578

579

580

581

582

583

584

585

586

587

588

589

590

591

592

593

594

595

596

597

598

/** * Returns the number of the last day of the month, taking into account * leap years.

* * @param month the month.

* @param yyyy the year (in the range 1900 to 9999).

* * @return the number of the last day of the month.

*/ public static int lastDayOfMonth(final int month, final int yyyy) {

final

int

result

=

LAST_DAY_OF_MONTH[month];

if (month != FEBRUARY) { return result; } else if (isLeapYear(yyyy)) {

return result + 1; } else {

return result; }

}

/** * Creates a new date by adding the specified number of days to the base * date.

* * @param days the number of days to add (can be negative).

* @param base the base date.

* * @return a new date.

*/ public static SerialDate addDays(final int days, final SerialDate base) {

final int serialDayNumber = base.toSerial() + days; return SerialDate.createInstance(serialDayNumber);

}

/** * Creates a new date by adding the specified number of months to the base * date.

* <P> * If the base date is close to the end of the month, the day on the result * may be adjusted slightly: 31 May + 1 month = 30 June.

* * @param months the number of months to add (can be negative).

* @param base the base date.

* * @return a new date.

*/ public static SerialDate addMonths(final int months, final SerialDate base) {

final int yy = (12 * base.getYYYY() + base.getMonth() + months - 1) / 12; final int mm = (12 * base.getYYYY() + base.getMonth() + months - 1) % 12 + 1; final int dd = Math.min( base.getDayOfMonth(), SerialDate.lastDayOfMonth(mm, yy) Appendix B: org.jfree.date.SerialDate

359

Listing B-1 (continued) SerialDate.Java

599

600

601

602

603

604

605

606

607

608

609

610

611

612

613

614

615

616

617

618

619

620

621

622

623

624

625

626

627

628

629

630

631

632

633

634

635

636

637

638

639

640

641

642

643

644

645

646

647

648

649

650

651

652

653

654

655

656

657

658

659

); return SerialDate.createInstance(dd, mm, yy);

}

/** * Creates a new date by adding the specified number of years to the base * date.

* * @param years the number of years to add (can be negative).

* @param base the base date.

* * @return A new date.

*/ public static SerialDate addYears(final int years, final SerialDate base) {

final int baseY = base.getYYYY(); final int baseM = base.getMonth(); final int baseD = base.getDayOfMonth();

final int targetY = baseY + years; final int targetD = Math.min( baseD, SerialDate.lastDayOfMonth(baseM, targetY) );

return SerialDate.createInstance(targetD, baseM, targetY);

}

/** * Returns the latest date that falls on the specified day-of-the-week and * is BEFORE the base date.

* * @param targetWeekday a code for the target day-of-the-week.

* @param base the base date.

* * @return the latest date that falls on the specified day-of-the-week and * is BEFORE the base date.

*/ public static SerialDate getPreviousDayOfWeek(final int targetWeekday, final SerialDate base) {

// check arguments...

if (!SerialDate.isValidWeekdayCode(targetWeekday)) {

throw new IllegalArgumentException(

"Invalid day-of-the-week code."

); }

// find the date...

final int adjust; final int baseDOW = base.getDayOfWeek(); if (baseDOW > targetWeekday) {

adjust = Math.min(0, targetWeekday - baseDOW); } else {

adjust = -7 + Math.max(0, targetWeekday - baseDOW); }

return SerialDate.addDays(adjust, base);

660

} 360

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

661

662

663

664

665

666

667

668

669

670

671

672

673

674

675

676

677

678

679

680

681

682

683

684

685

686

687

688

689

690

691

692

693

694

695

696

697

698

699

700

701

702

703

704

705

706

707

708

709

710

711

712

713

714

715

716

717

718

719

720

721

722

/** * Returns the earliest date that falls on the specified day-of-the-week * and is AFTER the base date.

* * @param targetWeekday a code for the target day-of-the-week.

* @param base the base date.

* * @return the earliest date that falls on the specified day-of-the-week * and is AFTER the base date.

*/ public static SerialDate getFollowingDayOfWeek(final int targetWeekday, final SerialDate base) {

// check arguments...

if (!SerialDate.isValidWeekdayCode(targetWeekday)) {

throw new IllegalArgumentException(

"Invalid day-of-the-week code."

); }

// find the date...

final int adjust; final int baseDOW = base.getDayOfWeek(); if (baseDOW > targetWeekday) {

adjust = 7 + Math.min(0, targetWeekday - baseDOW); } else {

adjust = Math.max(0, targetWeekday - baseDOW); }

return SerialDate.addDays(adjust, base);

}

/** * Returns the date that falls on the specified day-of-the-week and is * CLOSEST to the base date.

* * @param targetDOW a code for the target day-of-the-week.

* @param base the base date.

* * @return the date that falls on the specified day-of-the-week and is * CLOSEST to the base date.

*/ public static SerialDate getNearestDayOfWeek(final int targetDOW, final SerialDate base) {

// check arguments...

if (!SerialDate.isValidWeekdayCode(targetDOW)) {

throw new IllegalArgumentException(

"Invalid day-of-the-week code."

); }

// find the date...

final int baseDOW = base.getDayOfWeek(); int adjust = -Math.abs(targetDOW - baseDOW); if (adjust >= 4) {

adjust = 7 - adjust; } if (adjust <= -4) {

adjust = 7 + adjust; Appendix B: org.jfree.date.SerialDate

361

Listing B-1 (continued) SerialDate.Java

723

724

725

726

727

728

729

730

731

732

733

734

735

736

737

738

739

740

741

742

743

744

745

746

747

748

749

750

751

752

753

754

755

756

757

758

759

760

761

762

763

764

765

766

767

768

769

770

771

772

773

774

775

776

777

778

779

780

781

782

783

784

} return SerialDate.addDays(adjust, base);

}

/** * Rolls the date forward to the last day of the month.

* * @param base the base date.

* * @return a new serial date.

*/ public SerialDate getEndOfCurrentMonth(final SerialDate base) {

final int last = SerialDate.lastDayOfMonth(

base.getMonth(), base.getYYYY()

);

return SerialDate.createInstance(last, base.getMonth(), base.getYYYY()); }

/** * Returns a string corresponding to the week-in-the-month code.

* <P> * Need to find a better approach.

* * @param count an integer code representing the week-in-the-month. * * @return a string corresponding to the week-in-the-month code.

*/ public static String weekInMonthToString(final int count) {

switch (count) { case SerialDate.FIRST_WEEK_IN_MONTH : return "First"; case SerialDate.SECOND_WEEK_IN_MONTH : return "Second"; case SerialDate.THIRD_WEEK_IN_MONTH : return "Third"; case SerialDate.FOURTH_WEEK_IN_MONTH : return "Fourth"; case SerialDate.LAST_WEEK_IN_MONTH : return "Last"; default :

return "SerialDate.weekInMonthToString(): invalid code."; }

}

/** * Returns a string representing the supplied 'relative'. * <P> * Need to find a better approach.

* * @param relative a constant representing the 'relative'. * * @return a string representing the supplied 'relative'. */ public static String relativeToString(final int relative) {

switch (relative) { case SerialDate.PRECEDING : return "Preceding"; case SerialDate.NEAREST : return "Nearest"; case SerialDate.FOLLOWING : return "Following"; default : return "ERROR : Relative To String"; }

} 362

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

785

786

787

788

789

790

791

792

793

794

795

796

797

798

799

800

801

802

803

804

805

806

807

808

809

810

811

812

813

814

815

816

817

818

819

820

821

822

823

824

825

826

827

828

829

830

831

832

833

834

835

836

837

838

839

840

841

842

843

844

845

/** * Factory method that returns an instance of some concrete subclass of * {@link SerialDate}.

* * @param day the day (1-31).

* @param month the month (1-12).

* @param yyyy the year (in the range 1900 to 9999).

* * @return An instance of {@link SerialDate}.

*/ public static SerialDate createInstance(final int day, final int month, final int yyyy) { return new SpreadsheetDate(day, month, yyyy); }

/** * Factory method that returns an instance of some concrete subclass of * {@link SerialDate}.

* * @param serial the serial number for the day (1 January 1900 = 2). * * @return a instance of SerialDate.

*/ public static SerialDate createInstance(final int serial) { return new SpreadsheetDate(serial); }

/** * Factory method that returns an instance of a subclass of SerialDate. * * @param date A Java date object.

* * @return a instance of SerialDate.

*/ public static SerialDate createInstance(final java.util.Date date) {

final GregorianCalendar calendar = new GregorianCalendar(); calendar.setTime(date); return new SpreadsheetDate(calendar.get(Calendar.DATE),

calendar.get(Calendar.MONTH) + 1, calendar.get(Calendar.YEAR));

}

/** * Returns the serial number for the date, where 1 January 1900 = 2 (this * corresponds, almost, to the numbering system used in Microsoft Excel for * Windows and Lotus 1-2-3).

* * @return the serial number for the date.

*/ public abstract int toSerial();

/** * Returns a java.util.Date. Since java.util.Date has more precision than * SerialDate, we need to define a convention for the 'time of day'.

* * @return this as <code>java.util.Date</code>.

*/ public abstract java.util.Date toDate();

846

/** Appendix B: org.jfree.date.SerialDate

363

Listing B-1 (continued) SerialDate.Java

847

848

849

850

851

852

853

854

855

856

857

858

859

860

861

862

863

864

865

866

867

868

869

870

871

872

873

874

875

876

877

878

879

880

881

882

883

884

885

886

887

888

889

890

891

892

893

894

895

896

897

898

899

900

901

902

903

904

905

906

907

908

* Returns a description of the date. * * @return a description of the date. */ public String getDescription() { return this.description; }

/** * Sets the description for the date.

* * @param description the new description for the date. */ public void setDescription(final String description) { this.description = description; }

/** * Converts the date to a string.

* * @return a string representation of the date.

*/ public String toString() { return getDayOfMonth() + "-" + SerialDate.monthCodeToString(getMonth()) + "-" + getYYYY(); }

/** * Returns the year (assume a valid range of 1900 to 9999). * * @return the year.

*/ public abstract int getYYYY();

/** * Returns the month (January = 1, February = 2, March = 3). * * @return the month of the year.

*/ public abstract int getMonth();

/** * Returns the day of the month.

* * @return the day of the month.

*/ public abstract int getDayOfMonth();

/** * Returns the day of the week.

* * @return the day of the week.

*/ public abstract int getDayOfWeek();

/**

* Returns the difference (in days) between this date and the specified * 'other' date.

* <P> * The result is positive if this date is after the 'other' date and * negative if it is before the 'other' date.

* 364

Appendix B: org.jfree.date.SerialDate

Listing B-1 (continued) SerialDate.Java

909

910

911

912

913

914

915

916

917

918

919

920

921

922

923

924

925

926

927

928

929

930

931

932

933

934

935

936

937

938

939

940

941

942

943

944

945

946

947

948

949

950

951

952

953

954

955

956

957

958

959

960

961

962

963

964

965

966

967

968

969

970

971

* @param other the date being compared to.

* * @return the difference between this and the other date. */ public abstract int compare(SerialDate other);

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date as * the specified SerialDate.

*/ public abstract boolean isOn(SerialDate other);

/** * Returns true if this SerialDate represents an earlier date compared to * the specified SerialDate.

* * @param other The date being compared to.

* * @return <code>true</code> if this SerialDate represents an earlier date * compared to the specified SerialDate.

*/ public abstract boolean isBefore(SerialDate other);

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true<code> if this SerialDate represents the same date * as the specified SerialDate.

*/ public abstract boolean isOnOrBefore(SerialDate other);

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date * as the specified SerialDate.

*/ public abstract boolean isAfter(SerialDate other);

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date * as the specified SerialDate.

*/ public abstract boolean isOnOrAfter(SerialDate other);

/** * Returns <code>true</code> if this {@link SerialDate} is within the Appendix B: org.jfree.date.SerialDate

365

Listing B-1 (continued) SerialDate.Java

972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 }

* specified range (INCLUSIVE). The date order of d1 and d2 is not * important.

* * @param d1 a boundary date for the range.

* @param d2 the other boundary date for the range.

* * @return A boolean.

*/ public abstract boolean isInRange(SerialDate d1, SerialDate d2);

/** * Returns <code>true</code> if this {@link SerialDate} is within the * specified range (caller specifies whether or not the end-points are * included). The date order of d1 and d2 is not important.

* * @param d1 a boundary date for the range.

* @param d2 the other boundary date for the range.

* @param include a code that controls whether or not the start and end * dates are included in the range.

* * @return A boolean.

*/ public abstract boolean isInRange(SerialDate d1, SerialDate d2, int include);

/** * Returns the latest date that falls on the specified day-of-the-week and * is BEFORE this date.

* * @param targetDOW a code for the target day-of-the-week.

* * @return the latest date that falls on the specified day-of-the-week and * is BEFORE this date.

*/ public SerialDate getPreviousDayOfWeek(final int targetDOW) { return getPreviousDayOfWeek(targetDOW, this); }

/** * Returns the earliest date that falls on the specified day-of-the-week * and is AFTER this date.

* * @param targetDOW a code for the target day-of-the-week.

* * @return the earliest date that falls on the specified day-of-the-week * and is AFTER this date.

*/ public SerialDate getFollowingDayOfWeek(final int targetDOW) { return getFollowingDayOfWeek(targetDOW, this); }

/** * Returns the nearest date that falls on the specified day-of-the-week. * * @param targetDOW a code for the target day-of-the-week.

* * @return the nearest date that falls on the specified day-of-the-week. */ public SerialDate getNearestDayOfWeek(final int targetDOW) { return getNearestDayOfWeek(targetDOW, this); } 366

Appendix B: org.jfree.date.SerialDate

Listing B-2 SerialDateTest.java

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4 * 5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

6 * 7 * Project Info: http://www.jfree.org/jcommon/index.html 8 * 9 * This library is free software; you can redistribute it and/or modify it 10 * under the terms of the GNU Lesser General Public License as published by 11 * the Free Software Foundation; either version 2.1 of the License, or 12 * (at your option) any later version.

13 * 14 * This library is distributed in the hope that it will be useful, but 15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17 * License for more details.

18 * 19 * You should have received a copy of the GNU Lesser General Public 20 * License along with this library; if not, write to the Free Software 21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, 22 * USA.

23 * 24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.

25 * in the United States and other countries.] 26 * 27 * -------------------28 * SerialDateTests.java 29 * -------------------30 * (C) Copyright 2001-2005, by Object Refinery Limited.

31 * 32 * Original Author: David Gilbert (for Object Refinery Limited); 33 * Contributor(s): -; 34 * 35 * $Id: SerialDateTests.java,v 1.6 2005/11/16 15:58:40 taqua Exp $ 36 * 37 * Changes 38 * ------39 * 15-Nov-2001 : Version 1 (DG); 40 * 25-Jun-2002 : Removed unnecessary import (DG); 41 * 24-Oct-2002 : Fixed errors reported by Checkstyle (DG); 42 * 13-Mar-2003 : Added serialization test (DG); 43 * 05-Jan-2005 : Added test for bug report 1096282 (DG); 44 * 45 */ 46 47 package org.jfree.date.junit; 48 49 import java.io.ByteArrayInputStream; 50 import java.io.ByteArrayOutputStream; 51 import java.io.ObjectInput; 52 import java.io.ObjectInputStream; 53 import java.io.ObjectOutput; 54 import java.io.ObjectOutputStream; 55 56 import junit.framework.Test; 57 import junit.framework.TestCase; 58 import junit.framework.TestSuite; 59 60 import org.jfree.date.MonthConstants; 61 import org.jfree.date.SerialDate; 62 Appendix B: org.jfree.date.SerialDate

367

Listing B-2 (continued) SerialDateTest.java

63 /** 64 * Some JUnit tests for the {@link SerialDate} class.

65 */ 66 public class SerialDateTests extends TestCase { 67 68 /** Date representing November 9. */ 69 private SerialDate nov9Y2001; 70 71 /** 72 * Creates a new test case.

73 * 74 * @param name the name.

75 */ 76 public SerialDateTests(final String name) { 77 super(name); 78 } 79 80 /** 81 * Returns a test suite for the JUnit test runner.

82 * 83 * @return The test suite.

84 */ 85 public static Test suite() { 86 return new TestSuite(SerialDateTests.class); 87 } 88 89 /** 90 * Problem set up.

91 */ 92 protected void setUp() { 93 this.nov9Y2001 = SerialDate.createInstance(9, MonthConstants.NOVEMBER, 2001); 94 } 95 96 /** 97 * 9 Nov 2001 plus two months should be 9 Jan 2002.

98 */ 99 public void testAddMonthsTo9Nov2001() { 100 final SerialDate jan9Y2002 = SerialDate.addMonths(2, this.nov9Y2001); 101 final SerialDate answer = SerialDate.createInstance(9, 1, 2002); 102 assertEquals(answer, jan9Y2002); 103 } 104 105 /** 106 * A test case for a reported bug, now fixed.

107 */ 108 public void testAddMonthsTo5Oct2003() { 109 final SerialDate d1 = SerialDate.createInstance(5, MonthConstants.OCTOBER, 2003); 110 final SerialDate d2 = SerialDate.addMonths(2, d1); 111 assertEquals(d2, SerialDate.createInstance(5, MonthConstants.DECEMBER, 2003)); 112 } 113 114 /** 115 * A test case for a reported bug, now fixed.

116 */ 117 public void testAddMonthsTo1Jan2003() { 118 final SerialDate d1 = SerialDate.createInstance(1, MonthConstants.JANUARY, 2003); 119 final SerialDate d2 = SerialDate.addMonths(0, d1); 120 assertEquals(d2, d1); 121 } 122 123 /** 124 * Monday preceding Friday 9 November 2001 should be 5 November. 368

Appendix B: org.jfree.date.SerialDate

Listing B-2 (continued) SerialDateTest.java

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

177

178

179

180

181

182

183

184

*/ public void testMondayPrecedingFriday9Nov2001() { SerialDate mondayBefore = SerialDate.getPreviousDayOfWeek( SerialDate.MONDAY, this.nov9Y2001 ); assertEquals(5, mondayBefore.getDayOfMonth()); }

/** * Monday following Friday 9 November 2001 should be 12 November. */ public void testMondayFollowingFriday9Nov2001() {

SerialDate mondayAfter = SerialDate.getFollowingDayOfWeek(

SerialDate.MONDAY, this.nov9Y2001

);

assertEquals(12, mondayAfter.getDayOfMonth()); }

/** * Monday nearest Friday 9 November 2001 should be 12 November. */ public void testMondayNearestFriday9Nov2001() {

SerialDate mondayNearest = SerialDate.getNearestDayOfWeek(

SerialDate.MONDAY, this.nov9Y2001

);

assertEquals(12, mondayNearest.getDayOfMonth()); }

/** * The Monday nearest to 22nd January 1970 falls on the 19th. */ public void testMondayNearest22Jan1970() {

SerialDate jan22Y1970 = SerialDate.createInstance(22, MonthConstants.JANUARY, 1970);

SerialDate mondayNearest=SerialDate.getNearestDayOfWeek(SerialDate.MONDAY, jan22Y1970);

assertEquals(19, mondayNearest.getDayOfMonth()); }

/** * Problem that the conversion of days to strings returns the right result. * result depends on the Locale so this test needs to be modified.

*/ public void testWeekdayCodeToString() {

final String test = SerialDate.weekdayCodeToString(SerialDate.SATURDAY); assertEquals("Saturday", test);

}

Actually, this

/** * Test the conversion of a string to a weekday. Note that this test will fail if the * default locale doesn't use English weekday names...devise a better test!

*/ public void testStringToWeekday() {

int weekday = SerialDate.stringToWeekdayCode("Wednesday"); assertEquals(SerialDate.WEDNESDAY, weekday);

weekday = SerialDate.stringToWeekdayCode(" Wednesday "); assertEquals(SerialDate.WEDNESDAY, weekday); Appendix B: org.jfree.date.SerialDate

369

Listing B-2 (continued) SerialDateTest.java

185

186

187

188

189

190

191

192

193

194

195

196

197

198

199

200

201

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218

219

220

221

222

223

224

225

226

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

245

246

247

weekday = SerialDate.stringToWeekdayCode("Wed"); assertEquals(SerialDate.WEDNESDAY, weekday);

}

/** * Test the conversion of a string to a month. Note that this test will fail if the * default locale doesn't use English month names...devise a better test!

*/ public void testStringToMonthCode() {

int m = SerialDate.stringToMonthCode("January"); assertEquals(MonthConstants.JANUARY, m);

m = SerialDate.stringToMonthCode(" January "); assertEquals(MonthConstants.JANUARY, m);

m = SerialDate.stringToMonthCode("Jan"); assertEquals(MonthConstants.JANUARY, m);

}

/** * Tests the conversion of a month code to a string. */ public void testMonthCodeToStringCode() {

final String test = SerialDate.monthCodeToString(MonthConstants.DECEMBER); assertEquals("December", test);

}

/** * 1900 is not a leap year.

*/ public void testIsNotLeapYear1900() { assertTrue(!SerialDate.isLeapYear(1900)); }

/** * 2000 is a leap year.

*/ public void testIsLeapYear2000() { assertTrue(SerialDate.isLeapYear(2000)); }

/** * The number of leap years from 1900 up-to-and-including 1899 is 0. */ public void testLeapYearCount1899() { assertEquals(SerialDate.leapYearCount(1899), 0); }

/** * The number of leap years from 1900 up-to-and-including 1903 is 0. */ public void testLeapYearCount1903() { assertEquals(SerialDate.leapYearCount(1903), 0); }

/**

* The number of leap years from 1900 up-to-and-including 1904 is 1. */ 370

Appendix B: org.jfree.date.SerialDate

Listing B-2 (continued) SerialDateTest.java

248

249

250

251

252

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277

278

279

280

281

282

283

284

285

286

287

288

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

public void testLeapYearCount1904() { assertEquals(SerialDate.leapYearCount(1904), 1); }

/** * The number of leap years from 1900 up-to-and-including 1999 is 24. */ public void testLeapYearCount1999() { assertEquals(SerialDate.leapYearCount(1999), 24); }

/** * The number of leap years from 1900 up-to-and-including 2000 is 25. */ public void testLeapYearCount2000() { assertEquals(SerialDate.leapYearCount(2000), 25); }

/** * Serialize an instance, restore it, and check for equality. */ public void testSerialization() {

SerialDate d1 = SerialDate.createInstance(15, 4, 2000); SerialDate d2 = null;

try {

ByteArrayOutputStream buffer = new ByteArrayOutputStream(); ObjectOutput out = new ObjectOutputStream(buffer); out.writeObject(d1); out.close();

ObjectInput in = new ObjectInputStream( new ByteArrayInputStream(buffer.toByteArray())); d2 = (SerialDate) in.readObject(); in.close();

} catch (Exception e) { System.out.println(e.toString()); } assertEquals(d1, d2);

}

/** * A test for bug report 1096282 (now fixed). */ public void test1096282() {

SerialDate d = SerialDate.createInstance(29, 2, 2004);

d = SerialDate.addYears(1, d);

SerialDate expected = SerialDate.createInstance(28, 2, 2005);

assertTrue(d.isOn(expected)); }

/** * Miscellaneous tests for the addMonths() method.

*/ public void testAddMonths() { SerialDate d1 = SerialDate.createInstance(31, 5, 2004); Appendix B: org.jfree.date.SerialDate

371

Listing B-2 (continued) SerialDateTest.java

307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 }

SerialDate d2 = SerialDate.addMonths(1, d1); assertEquals(30, d2.getDayOfMonth()); assertEquals(6, d2.getMonth()); assertEquals(2004, d2.getYYYY());

SerialDate d3 = SerialDate.addMonths(2, d1); assertEquals(31, d3.getDayOfMonth()); assertEquals(7, d3.getMonth()); assertEquals(2004, d3.getYYYY());

SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1)); assertEquals(30, d4.getDayOfMonth()); assertEquals(7, d4.getMonth()); assertEquals(2004, d4.getYYYY());

} 372

Appendix B: org.jfree.date.SerialDate

Listing B-3 MonthConstants.java

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4 * 5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

6 * 7 * Project Info: http://www.jfree.org/jcommon/index.html 8 * 9 * This library is free software; you can redistribute it and/or modify it 10 * under the terms of the GNU Lesser General Public License as published by 11 * the Free Software Foundation; either version 2.1 of the License, or 12 * (at your option) any later version.

13 * 14 * This library is distributed in the hope that it will be useful, but 15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17 * License for more details.

18 * 19 * You should have received a copy of the GNU Lesser General Public 20 * License along with this library; if not, write to the Free Software 21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, 22 * USA.

23 * 24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.

25 * in the United States and other countries.] 26 * 27 * ------------------28 * MonthConstants.java 29 * ------------------30 * (C) Copyright 2002, 2003, by Object Refinery Limited.

31 * 32 * Original Author: David Gilbert (for Object Refinery Limited); 33 * Contributor(s): -; 34 * 35 * $Id: MonthConstants.java,v 1.4 2005/11/16 15:58:40 taqua Exp $ 36 * 37 * Changes 38 * ------39 * 29-May-2002 : Version 1 (code moved from SerialDate class) (DG); 40 * 41 */ 42 43 package org.jfree.date; 44

45 /** 46 * Useful constants for months. Note that these are NOT equivalent to the 47 * constants defined by java.util.Calendar (where JANUARY=0 and DECEMBER=11). 48 * <P> 49 * Used by the SerialDate and RegularTimePeriod classes.

50 * 51 * @author David Gilbert 52 */ 53 public interface MonthConstants { 54 55 /** Constant for January. */ 56 public static final int JANUARY = 1; 57 58 /** Constant for February. */ 59 public static final int FEBRUARY = 2; 60 Appendix B: org.jfree.date.SerialDate

373

Listing B-3 (continued) MonthConstants.java

61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 }

/** Constant for March. */ public static final int MARCH = 3;

/** Constant for April. */ public static final int APRIL = 4;

/** Constant for May. */ public static final int MAY = 5;

/** Constant for June. */ public static final int JUNE = 6;

/** Constant for July. */ public static final int JULY = 7;

/** Constant for August. */ public static final int AUGUST = 8;

/** Constant for September. */ public static final int SEPTEMBER = 9;

/** Constant for October. */ public static final int OCTOBER = 10;

/** Constant for November. */ public static final int NOVEMBER = 11;

/** Constant for December. */ public static final int DECEMBER = 12; 374

Appendix B: org.jfree.date.SerialDate

Listing B-4 BobsSerialDateTest.java

1 package org.jfree.date.junit; 2 3 import junit.framework.TestCase; 4 import org.jfree.date.*; 5 import static org.jfree.date.SerialDate.*; 6 7 import java.util.*; 8 9 public class BobsSerialDateTest extends TestCase { 10 11 public void testIsValidWeekdayCode() throws Exception { 12 13 assertTrue(isValidWeekdayCode(day)); 14 assertFalse(isValidWeekdayCode(0)); 15 assertFalse(isValidWeekdayCode(8)); 16 } 17 18 public void testStringToWeekdayCode() throws Exception { 19 20 assertEquals(-1, stringToWeekdayCode("Hello")); 21 assertEquals(MONDAY, stringToWeekdayCode("Monday")); 22 assertEquals(MONDAY, stringToWeekdayCode("Mon")); 23 //todo assertEquals(MONDAY,stringToWeekdayCode("monday")); 24 // assertEquals(MONDAY,stringToWeekdayCode("MONDAY")); 25 // assertEquals(MONDAY, stringToWeekdayCode("mon")); 26 27 assertEquals(TUESDAY, stringToWeekdayCode("Tuesday")); 28 assertEquals(TUESDAY, stringToWeekdayCode("Tue")); 29 // assertEquals(TUESDAY,stringToWeekdayCode("tuesday")); 30 // assertEquals(TUESDAY,stringToWeekdayCode("TUESDAY")); 31 // assertEquals(TUESDAY, stringToWeekdayCode("tue")); 32 // assertEquals(TUESDAY, stringToWeekdayCode("tues")); 33 34 assertEquals(WEDNESDAY, stringToWeekdayCode("Wednesday")); 35 assertEquals(WEDNESDAY, stringToWeekdayCode("Wed")); 36 // assertEquals(WEDNESDAY,stringToWeekdayCode("wednesday")); 37 // assertEquals(WEDNESDAY,stringToWeekdayCode("WEDNESDAY")); 38 // assertEquals(WEDNESDAY, stringToWeekdayCode("wed")); 39 40 assertEquals(THURSDAY, stringToWeekdayCode("Thursday")); 41 assertEquals(THURSDAY, stringToWeekdayCode("Thu")); 42 // assertEquals(THURSDAY,stringToWeekdayCode("thursday")); 43 // assertEquals(THURSDAY,stringToWeekdayCode("THURSDAY")); 44 // assertEquals(THURSDAY, stringToWeekdayCode("thu")); 45 // assertEquals(THURSDAY, stringToWeekdayCode("thurs")); 46 47 assertEquals(FRIDAY, stringToWeekdayCode("Friday")); 48 assertEquals(FRIDAY, stringToWeekdayCode("Fri")); 49 // assertEquals(FRIDAY,stringToWeekdayCode("friday")); 50 // assertEquals(FRIDAY,stringToWeekdayCode("FRIDAY")); 51 // assertEquals(FRIDAY, stringToWeekdayCode("fri")); 52 53 assertEquals(SATURDAY, stringToWeekdayCode("Saturday")); 54 assertEquals(SATURDAY, stringToWeekdayCode("Sat")); 55 // assertEquals(SATURDAY,stringToWeekdayCode("saturday")); 56 // assertEquals(SATURDAY,stringToWeekdayCode("SATURDAY")); 57 // assertEquals(SATURDAY, stringToWeekdayCode("sat")); 58 59 assertEquals(SUNDAY, stringToWeekdayCode("Sunday")); 60 assertEquals(SUNDAY, stringToWeekdayCode("Sun")); 61 // assertEquals(SUNDAY,stringToWeekdayCode("sunday")); 62 // assertEquals(SUNDAY,stringToWeekdayCode("SUNDAY")); 63 // assertEquals(SUNDAY, stringToWeekdayCode("sun")); 64 } 65

for

(int

day

=

1;

day

<=

7;

day++) Appendix B: org.jfree.date.SerialDate

375

Listing B-4 (continued) BobsSerialDateTest.java

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

public void testWeekdayCodeToString() throws Exception { assertEquals("Sunday", weekdayCodeToString(SUNDAY)); assertEquals("Monday", weekdayCodeToString(MONDAY)); assertEquals("Tuesday", weekdayCodeToString(TUESDAY)); assertEquals("Wednesday", weekdayCodeToString(WEDNESDAY)); assertEquals("Thursday", weekdayCodeToString(THURSDAY)); assertEquals("Friday", weekdayCodeToString(FRIDAY)); assertEquals("Saturday", weekdayCodeToString(SATURDAY)); }

public void testIsValidMonthCode() throws Exception {

for

(int

i

=

1;

i

<=

12;

i++)

assertTrue(isValidMonthCode(i)); assertFalse(isValidMonthCode(0)); assertFalse(isValidMonthCode(13));

}

public void testMonthToQuarter() throws Exception { assertEquals(1, monthCodeToQuarter(JANUARY)); assertEquals(1, monthCodeToQuarter(FEBRUARY)); assertEquals(1, monthCodeToQuarter(MARCH)); assertEquals(2, monthCodeToQuarter(APRIL)); assertEquals(2, monthCodeToQuarter(MAY)); assertEquals(2, monthCodeToQuarter(JUNE)); assertEquals(3, monthCodeToQuarter(JULY)); assertEquals(3, monthCodeToQuarter(AUGUST)); assertEquals(3, monthCodeToQuarter(SEPTEMBER)); assertEquals(4, monthCodeToQuarter(OCTOBER)); assertEquals(4, monthCodeToQuarter(NOVEMBER)); assertEquals(4, monthCodeToQuarter(DECEMBER));

try { monthCodeToQuarter(-1); fail("Invalid Month Code should throw exception"); } catch (IllegalArgumentException e) { }

}

public void testMonthCodeToString() throws Exception {

assertEquals("January", monthCodeToString(JANUARY)); assertEquals("February", monthCodeToString(FEBRUARY)); assertEquals("March", monthCodeToString(MARCH)); assertEquals("April", monthCodeToString(APRIL)); assertEquals("May", monthCodeToString(MAY)); assertEquals("June", monthCodeToString(JUNE)); assertEquals("July", monthCodeToString(JULY)); assertEquals("August", monthCodeToString(AUGUST)); assertEquals("September", monthCodeToString(SEPTEMBER)); assertEquals("October", monthCodeToString(OCTOBER)); assertEquals("November", monthCodeToString(NOVEMBER)); assertEquals("December", monthCodeToString(DECEMBER));

assertEquals("Jan", monthCodeToString(JANUARY, true)); assertEquals("Feb", monthCodeToString(FEBRUARY, true)); assertEquals("Mar", monthCodeToString(MARCH, true)); assertEquals("Apr", monthCodeToString(APRIL, true)); assertEquals("May", monthCodeToString(MAY, true)); assertEquals("Jun", monthCodeToString(JUNE, true)); assertEquals("Jul", monthCodeToString(JULY, true)); assertEquals("Aug", monthCodeToString(AUGUST, true)); assertEquals("Sep", monthCodeToString(SEPTEMBER, true)); assertEquals("Oct", monthCodeToString(OCTOBER, true)); 376

Appendix B: org.jfree.date.SerialDate

Listing B-4 (continued) BobsSerialDateTest.java

128 129 130 131 132 133 134 135 136 137 } 138 139 public void testStringToMonthCode() throws Exception { 140 assertEquals(JANUARY,stringToMonthCode("1")); 141 assertEquals(FEBRUARY,stringToMonthCode("2")); 142 assertEquals(MARCH,stringToMonthCode("3")); 143 assertEquals(APRIL,stringToMonthCode("4")); 144 assertEquals(MAY,stringToMonthCode("5")); 145 assertEquals(JUNE,stringToMonthCode("6")); 146 assertEquals(JULY,stringToMonthCode("7")); 147 assertEquals(AUGUST,stringToMonthCode("8")); 148 assertEquals(SEPTEMBER,stringToMonthCode("9")); 149 assertEquals(OCTOBER,stringToMonthCode("10")); 150 assertEquals(NOVEMBER, stringToMonthCode("11")); 151 assertEquals(DECEMBER,stringToMonthCode("12")); 152 153 //todo assertEquals(-1, stringToMonthCode("0")); 154 // assertEquals(-1, stringToMonthCode("13")); 155 156 assertEquals(-1,stringToMonthCode("Hello")); 157 158 159 assertEquals(m, stringToMonthCode(monthCodeToString(m, false))); 160 assertEquals(m, stringToMonthCode(monthCodeToString(m, true))); 161 } 162 163 // assertEquals(1,stringToMonthCode("jan")); 164 // assertEquals(2,stringToMonthCode("feb")); 165 // assertEquals(3,stringToMonthCode("mar")); 166 // assertEquals(4,stringToMonthCode("apr")); 167 // assertEquals(5,stringToMonthCode("may")); 168 // assertEquals(6,stringToMonthCode("jun")); 169 // assertEquals(7,stringToMonthCode("jul")); 170 // assertEquals(8,stringToMonthCode("aug")); 171 // assertEquals(9,stringToMonthCode("sep")); 172 // assertEquals(10,stringToMonthCode("oct")); 173 // assertEquals(11,stringToMonthCode("nov")); 174 // assertEquals(12,stringToMonthCode("dec")); 175 176 // assertEquals(1,stringToMonthCode("JAN")); 177 // assertEquals(2,stringToMonthCode("FEB")); 178 // assertEquals(3,stringToMonthCode("MAR")); 179 // assertEquals(4,stringToMonthCode("APR")); 180 // assertEquals(5,stringToMonthCode("MAY")); 181 // assertEquals(6,stringToMonthCode("JUN")); 182 // assertEquals(7,stringToMonthCode("JUL")); 183 // assertEquals(8,stringToMonthCode("AUG")); 184 // assertEquals(9,stringToMonthCode("SEP")); 185 // assertEquals(10,stringToMonthCode("OCT")); 186 // assertEquals(11,stringToMonthCode("NOV")); 187 // assertEquals(12,stringToMonthCode("DEC")); 188 189 // assertEquals(1,stringToMonthCode("january")); 190 // assertEquals(2,stringToMonthCode("february"));

assertEquals("Nov", monthCodeToString(NOVEMBER, true)); assertEquals("Dec", monthCodeToString(DECEMBER, true));

try { monthCodeToString(-1); fail("Invalid month code should throw exception"); } catch (IllegalArgumentException e) { }

for

(int

m

=

1;

m

<=

12;

m++)

{ Appendix B: org.jfree.date.SerialDate

377

Listing B-4 (continued) BobsSerialDateTest.java

191 // 192 // 193 // 194 // 195 // 196 // 197 // 198 // 199 // 200 // 201 202 // 203 // 204 // 205 // 206 // 207 // 208 // 209 // 210 // 211 // 212 // 213 // 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251

assertEquals(3,stringToMonthCode("march")); assertEquals(4,stringToMonthCode("april")); assertEquals(5,stringToMonthCode("may")); assertEquals(6,stringToMonthCode("june")); assertEquals(7,stringToMonthCode("july")); assertEquals(8,stringToMonthCode("august")); assertEquals(9,stringToMonthCode("september")); assertEquals(10,stringToMonthCode("october")); assertEquals(11,stringToMonthCode("november")); assertEquals(12,stringToMonthCode("december"));

assertEquals(1,stringToMonthCode("JANUARY")); assertEquals(2,stringToMonthCode("FEBRUARY")); assertEquals(3,stringToMonthCode("MAR")); assertEquals(4,stringToMonthCode("APRIL")); assertEquals(5,stringToMonthCode("MAY")); assertEquals(6,stringToMonthCode("JUNE")); assertEquals(7,stringToMonthCode("JULY")); assertEquals(8,stringToMonthCode("AUGUST")); assertEquals(9,stringToMonthCode("SEPTEMBER")); assertEquals(10,stringToMonthCode("OCTOBER")); assertEquals(11,stringToMonthCode("NOVEMBER")); assertEquals(12,stringToMonthCode("DECEMBER"));

}

public void testIsValidWeekInMonthCode() throws Exception {

for

(int

w

=

0;

w

<=

4;

w++)

{

assertTrue(isValidWeekInMonthCode(w));

} assertFalse(isValidWeekInMonthCode(5));

}

public void testIsLeapYear() throws Exception { assertFalse(isLeapYear(1900)); assertFalse(isLeapYear(1901)); assertFalse(isLeapYear(1902)); assertFalse(isLeapYear(1903)); assertTrue(isLeapYear(1904)); assertTrue(isLeapYear(1908)); assertFalse(isLeapYear(1955)); assertTrue(isLeapYear(1964)); assertTrue(isLeapYear(1980)); assertTrue(isLeapYear(2000)); assertFalse(isLeapYear(2001)); assertFalse(isLeapYear(2100));

}

public void testLeapYearCount() throws Exception { assertEquals(0, leapYearCount(1900)); assertEquals(0, leapYearCount(1901)); assertEquals(0, leapYearCount(1902)); assertEquals(0, leapYearCount(1903)); assertEquals(1, leapYearCount(1904)); assertEquals(1, leapYearCount(1905)); assertEquals(1, leapYearCount(1906)); assertEquals(1, leapYearCount(1907)); assertEquals(2, leapYearCount(1908)); assertEquals(24, leapYearCount(1999)); assertEquals(25, leapYearCount(2001)); assertEquals(49, leapYearCount(2101)); assertEquals(73, leapYearCount(2201)); 378

Appendix B: org.jfree.date.SerialDate

Listing B-4 (continued) BobsSerialDateTest.java

252 assertEquals(97, leapYearCount(2301)); 253 assertEquals(122, leapYearCount(2401)); 254 } 255 256 public void testLastDayOfMonth() throws Exception { 257 assertEquals(31, lastDayOfMonth(JANUARY, 1901)); 258 assertEquals(28, lastDayOfMonth(FEBRUARY, 1901)); 259 assertEquals(31, lastDayOfMonth(MARCH, 1901)); 260 assertEquals(30, lastDayOfMonth(APRIL, 1901)); 261 assertEquals(31, lastDayOfMonth(MAY, 1901)); 262 assertEquals(30, lastDayOfMonth(JUNE, 1901)); 263 assertEquals(31, lastDayOfMonth(JULY, 1901)); 264 assertEquals(31, lastDayOfMonth(AUGUST, 1901)); 265 assertEquals(30, lastDayOfMonth(SEPTEMBER, 1901)); 266 assertEquals(31, lastDayOfMonth(OCTOBER, 1901)); 267 assertEquals(30, lastDayOfMonth(NOVEMBER, 1901)); 268 assertEquals(31, lastDayOfMonth(DECEMBER, 1901)); 269 assertEquals(29, lastDayOfMonth(FEBRUARY, 1904)); 270 } 271 272 public void testAddDays() throws Exception { 273 SerialDate newYears = d(1, JANUARY, 1900); 274 assertEquals(d(2, JANUARY, 1900), addDays(1, newYears)); 275 assertEquals(d(1, FEBRUARY, 1900), addDays(31, newYears)); 276 assertEquals(d(1, JANUARY, 1901), addDays(365, newYears)); 277 assertEquals(d(31, DECEMBER, 1904), addDays(5 * 365, newYears)); 278 } 279 280 private static SpreadsheetDate d(int day, int month, int year) {return new SpreadsheetDate(day, month, year);} 281 282 public void testAddMonths() throws Exception { 283 assertEquals(d(1, FEBRUARY, 1900), addMonths(1, d(1, JANUARY, 1900))); 284 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(31, JANUARY, 1900))); 285 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(30, JANUARY, 1900))); 286 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(29, JANUARY, 1900))); 287 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(28, JANUARY, 1900))); 288 assertEquals(d(27, FEBRUARY, 1900), addMonths(1, d(27, JANUARY, 1900))); 289 290 assertEquals(d(30, JUNE, 1900), addMonths(5, d(31, JANUARY, 1900))); 291 assertEquals(d(30, JUNE, 1901), addMonths(17, d(31, JANUARY, 1900))); 292 293 assertEquals(d(29, FEBRUARY, 1904), addMonths(49, d(31, JANUARY, 1900))); 294 295 } 296 297 public void testAddYears() throws Exception { 298 assertEquals(d(1, JANUARY, 1901), addYears(1, d(1, JANUARY, 1900))); 299 assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(29, FEBRUARY, 1904))); 300 assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(28, FEBRUARY, 1904))); 301 assertEquals(d(28, FEBRUARY, 1904), addYears(1, d(28, FEBRUARY, 1903))); 302 } 303 304 public void testGetPreviousDayOfWeek() throws Exception { 305 assertEquals(d(24, FEBRUARY, 2006), getPreviousDayOfWeek(FRIDAY, d(1, MARCH, 2006))); 306 assertEquals(d(22, FEBRUARY, 2006), getPreviousDayOfWeek(WEDNESDAY, d(1, MARCH, 2006))); 307 assertEquals(d(29, FEBRUARY, 2004), getPreviousDayOfWeek(SUNDAY, d(3, MARCH, 2004))); 308 assertEquals(d(29, DECEMBER, 2004), getPreviousDayOfWeek(WEDNESDAY, d(5, JANUARY, 2005))); 309 310 try { 311 getPreviousDayOfWeek(-1, d(1, JANUARY, 2006)); 312 fail("Invalid day of week code should throw exception"); Appendix B: org.jfree.date.SerialDate

379

Listing B-4 (continued) BobsSerialDateTest.java

313 } catch (IllegalArgumentException e) { 314 } 315 } 316 317 public void testGetFollowingDayOfWeek() throws Exception { 318 // assertEquals(d(1, JANUARY, 2005),getFollowingDayOfWeek(SATURDAY, d(25, DECEMBER, 2004))); 319 assertEquals(d(1, JANUARY, 2005), getFollowingDayOfWeek(SATURDAY, d(26, DECEMBER, 2004))); 320 assertEquals(d(3, MARCH, 2004), getFollowingDayOfWeek(WEDNESDAY, d(28, FEBRUARY, 2004))); 321 322 try { 323 getFollowingDayOfWeek(-1, d(1, JANUARY, 2006)); 324 fail("Invalid day of week code should throw exception"); 325 } catch (IllegalArgumentException e) { 326 } 327 } 328 329 public void testGetNearestDayOfWeek() throws Exception { 330 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(16, APRIL, 2006))); 331 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(17, APRIL, 2006))); 332 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(18, APRIL, 2006))); 333 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(19, APRIL, 2006))); 334 assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(20, APRIL, 2006))); 335 assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(21, APRIL, 2006))); 336 assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(22, APRIL, 2006))); 337 338 //todo assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(16, APRIL, 2006))); 339 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(17, APRIL, 2006))); 340 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(18, APRIL, 2006))); 341 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(19, APRIL, 2006))); 342 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(20, APRIL, 2006))); 343 assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(21, APRIL, 2006))); 344 assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(22, APRIL, 2006))); 345 346 // assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(16, APRIL, 2006))); 347 // assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(17, APRIL, 2006))); 348 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(18, APRIL, 2006))); 349 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(19, APRIL, 2006))); 350 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(20, APRIL, 2006))); 351 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(21, APRIL, 2006))); 352 assertEquals(d(25, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(22, APRIL, 2006))); 353 354 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(16, APRIL, 2006))); 355 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(17, APRIL, 2006))); 356 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(18, APRIL, 2006))); 357 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(19, APRIL, 2006))); 358 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(20, APRIL, 2006))); 359 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(21, APRIL, 2006))); 360 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(22, APRIL, 2006))); 361 362 // assertEquals(d(13, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(16, APRIL, 2006))); 363 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(17, APRIL, 2006))); 364 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(18, APRIL, 2006))); 365 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(19, APRIL, 2006))); 366 assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(20, APRIL, 2006))); 367 assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(21, APRIL, 2006))); 368 assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(22, APRIL, 2006))); 369 370 // assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(16, APRIL, 2006))); 371 // assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(17, APRIL, 2006))); 372 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(18, APRIL, 2006))); 373 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(19, APRIL, 2006))); 374 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(20, APRIL, 2006))); 380

Appendix B: org.jfree.date.SerialDate

Listing B-4 (continued) BobsSerialDateTest.java

375 assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(21, APRIL, 2006))); 376 assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(22, APRIL, 2006))); 377 378 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(16, APRIL, 2006))); 379 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(17, APRIL, 2006))); 380 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(18, APRIL, 2006))); 381 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(19, APRIL, 2006))); 382 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(20, APRIL, 2006))); 383 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(21, APRIL, 2006))); 384 assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(22, APRIL, 2006))); 385 386 try { 387 getNearestDayOfWeek(-1, d(1, JANUARY, 2006)); 388 fail("Invalid day of week code should throw exception"); 389 } catch (IllegalArgumentException e) { 390 } 391 } 392 393 public void testEndOfCurrentMonth() throws Exception { 394 SerialDate d = SerialDate.createInstance(2); 395 assertEquals(d(31, JANUARY, 2006), d.getEndOfCurrentMonth(d(1, JANUARY, 2006))); 396 assertEquals(d(28, FEBRUARY, 2006), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2006))); 397 assertEquals(d(31, MARCH, 2006), d.getEndOfCurrentMonth(d(1, MARCH, 2006))); 398 assertEquals(d(30, APRIL, 2006), d.getEndOfCurrentMonth(d(1, APRIL, 2006))); 399 assertEquals(d(31, MAY, 2006), d.getEndOfCurrentMonth(d(1, MAY, 2006))); 400 assertEquals(d(30, JUNE, 2006), d.getEndOfCurrentMonth(d(1, JUNE, 2006))); 401 assertEquals(d(31, JULY, 2006), d.getEndOfCurrentMonth(d(1, JULY, 2006))); 402 assertEquals(d(31, AUGUST, 2006), d.getEndOfCurrentMonth(d(1, AUGUST, 2006))); 403 assertEquals(d(30, SEPTEMBER, 2006), d.getEndOfCurrentMonth(d(1, SEPTEMBER, 2006))); 404 assertEquals(d(31, OCTOBER, 2006), d.getEndOfCurrentMonth(d(1, OCTOBER, 2006))); 405 assertEquals(d(30, NOVEMBER, 2006), d.getEndOfCurrentMonth(d(1, NOVEMBER, 2006))); 406 assertEquals(d(31, DECEMBER, 2006), d.getEndOfCurrentMonth(d(1, DECEMBER, 2006))); 407 assertEquals(d(29, FEBRUARY, 2008), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2008))); 408 } 409 410 public void testWeekInMonthToString() throws Exception { 411 assertEquals("First",weekInMonthToString(FIRST_WEEK_IN_MONTH)); 412 assertEquals("Second",weekInMonthToString(SECOND_WEEK_IN_MONTH)); 413 assertEquals("Third",weekInMonthToString(THIRD_WEEK_IN_MONTH)); 414 assertEquals("Fourth",weekInMonthToString(FOURTH_WEEK_IN_MONTH)); 415 assertEquals("Last",weekInMonthToString(LAST_WEEK_IN_MONTH)); 416 417 //todo try { 418 // weekInMonthToString(-1); 419 // fail("Invalid week code should throw exception"); 420 // } catch (IllegalArgumentException e) { 421 // } 422 } 423 424 public void testRelativeToString() throws Exception { 425 assertEquals("Preceding",relativeToString(PRECEDING)); 426 assertEquals("Nearest",relativeToString(NEAREST)); 427 assertEquals("Following",relativeToString(FOLLOWING)); 428 429 //todo try { 430 // relativeToString(-1000); 431 // fail("Invalid relative code should throw exception"); 432 // } catch (IllegalArgumentException e) { 433 // } 434 } 435 Appendix B: org.jfree.date.SerialDate

381

Listing B-4 (continued) BobsSerialDateTest.java

436

437

438

439

440

441

442

443

444

445

446

447

448

449

450

451

452 453 454 455 456 457 }

public void testCreateInstanceFromDDMMYYY() throws Exception { SerialDate date = createInstance(1, JANUARY, 1900); assertEquals(1,date.getDayOfMonth()); assertEquals(JANUARY,date.getMonth()); assertEquals(1900,date.getYYYY()); assertEquals(2,date.toSerial()); }

public void testCreateInstanceFromSerial() throws Exception { assertEquals(d(1, JANUARY, 1900),createInstance(2)); assertEquals(d(1, JANUARY, 1901), createInstance(367)); }

public void testCreateInstanceFromJavaDate() throws Exception { assertEquals(d(1, JANUARY, 1900), createInstance(new GregorianCalendar(1900,0,1).getTime()));

assertEquals(d(1, JANUARY, 2006), createInstance(new GregorianCalendar(2006,0,1).getTime())); }

public static void main(String[] args) { junit.textui.TestRunner.run(BobsSerialDateTest.class); } 382

Appendix B: org.jfree.date.SerialDate

Listing B-5 SpreadsheetDate.java

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4 * 5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

6 * 7 * Project Info: http://www.jfree.org/jcommon/index.html 8 * 9 * This library is free software; you can redistribute it and/or modify it 10 * under the terms of the GNU Lesser General Public License as published by 11 * the Free Software Foundation; either version 2.1 of the License, or 12 * (at your option) any later version.

13 * 14 * This library is distributed in the hope that it will be useful, but 15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17 * License for more details.

18 * 19 * You should have received a copy of the GNU Lesser General Public 20 * License along with this library; if not, write to the Free Software 21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, 22 * USA.

23 * 24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.

25 * in the United States and other countries.] 26 * 27 * -------------------28 * SpreadsheetDate.java 29 * -------------------30 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

31 * 32 * Original Author: David Gilbert (for Object Refinery Limited); 33 * Contributor(s): -; 34 * 35 * $Id: SpreadsheetDate.java,v 1.8 2005/11/03 09:25:39 mungady Exp $ 36 * 37 * Changes 38 * ------39 * 11-Oct-2001 : Version 1 (DG); 40 * 05-Nov-2001 : Added getDescription() and setDescription() methods (DG); 41 * 12-Nov-2001 : Changed name from ExcelDate.java to SpreadsheetDate.java (DG); 42 * Fixed a bug in calculating day, month and year from serial 43 * number (DG); 44 * 24-Jan-2002 : Fixed a bug in calculating the serial number from the day, 45 * month and year. Thanks to Trevor Hills for the report (DG); 46 * 29-May-2002 : Added equals(Object) method (SourceForge ID 558850) (DG); 47 * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG); 48 * 13-Mar-2003 : Implemented Serializable (DG); 49 * 04-Sep-2003 : Completed isInRange() methods (DG); 50 * 05-Sep-2003 : Implemented Comparable (DG); 51 * 21-Oct-2003 : Added hashCode() method (DG); 52 * 53 */ 54 55 package org.jfree.date; 56 57 import java.util.Calendar; 58 import java.util.Date; 59 60 /** 61 * Represents a date using an integer, in a similar fashion to the 62 * implementation in Microsoft Excel. The range of dates supported is Appendix B: org.jfree.date.SerialDate

383

Listing B-5 (continued) SpreadsheetDate.java

63 * 1-Jan-1900 to 31-Dec-9999.

64 * <P> 65 * Be aware that there is a deliberate bug in Excel that recognises the year 66 * 1900 as a leap year when in fact it is not a leap year. You can find more 67 * information on the Microsoft website in article Q181370:

68 * <P> 69 * http://support.microsoft.com/support/kb/articles/Q181/3/70.asp 70 * <P> 71 * Excel uses the convention that 1-Jan-1900 = 1. This class uses the 72 * convention 1-Jan-1900 = 2.

73 * The result is that the day number in this class will be different to the 74 * Excel figure for January and February 1900...but then Excel adds in an extra 75 * day (29-Feb-1900 which does not actually exist!) and from that point forward 76 * the day numbers will match.

77 * 78 * @author David Gilbert 79 */ 80 public class SpreadsheetDate extends SerialDate { 81 82 /** For serialization. */ 83 private static final long serialVersionUID = -2039586705374454461L; 84 85 /** 86 * The day number (1-Jan-1900 = 2, 2-Jan-1900 = 3, ..., 31-Dec-9999 = 87 * 2958465).

88 */ 89 private int serial; 90 91 /** The day of the month (1 to 28, 29, 30 or 31 depending on the month). */ 92 private int day; 93 94 /** The month of the year (1 to 12). */ 95 private int month; 96 97 /** The year (1900 to 9999). */ 98 private int year; 99 100 /** An optional description for the date. */ 101 private String description; 102 103 /** 104 * Creates a new date instance.

105 * 106 * @param day the day (in the range 1 to 28/29/30/31).

107 * @param month the month (in the range 1 to 12).

108 * @param year the year (in the range 1900 to 9999).

109 */ 110 public SpreadsheetDate(final int day, final int month, final int year) { 111 112 if ((year >= 1900) && (year <= 9999)) { 113 this.year = year; 114 } 115 else { 116 throw new IllegalArgumentException( 117 "The 'year' argument must be in range 1900 to 9999."

118 ); 119 } 120 121 if ((month >= MonthConstants.JANUARY) 122 && (month <= MonthConstants.DECEMBER)) { 123 this.month = month; 124 } 384

Appendix B: org.jfree.date.SerialDate

Listing B-5 (continued) SpreadsheetDate.java

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

177

178

179

180

181

182

183

184

185

186

else { throw new IllegalArgumentException( "The 'month' argument must be in the range 1 to 12."

); }

if ((day >= 1) && (day <= SerialDate.lastDayOfMonth(month, year))) { this.day = day; } else {

throw new IllegalArgumentException("Invalid 'day' argument."); }

// the serial number needs to be synchronised with the day-month-year... this.serial = calcSerial(day, month, year);

this.description = null;

}

/** * Standard constructor - creates a new date object representing the * specified day number (which should be in the range 2 to 2958465.

* * @param serial the serial number for the day (range: 2 to 2958465). */ public SpreadsheetDate(final int serial) {

if ((serial >= SERIAL_LOWER_BOUND) && (serial <= SERIAL_UPPER_BOUND)) { this.serial = serial; } else {

throw new IllegalArgumentException(

"SpreadsheetDate: Serial must be in range 2 to 2958465."); }

// the day-month-year needs to be synchronised with the serial number... calcDayMonthYear();

}

/** * Returns the description that is attached to the date. It is not * required that a date have a description, but for some applications it * is useful.

* * @return The description that is attached to the date.

*/ public String getDescription() { return this.description; }

/** * Sets the description for the date.

* * @param description the description for this date (<code>null</code> * permitted).

*/ public void setDescription(final String description) { this.description = description; } Appendix B: org.jfree.date.SerialDate

385

Listing B-5 (continued) SpreadsheetDate.java

187

188

189

190

191

192

193

194

195

196

197

198

199

200

201

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218

219

220

221

222

223

224

225

226

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

245

246

247

248

/** * Returns the serial number for the date, where 1 January 1900 = 2 * (this corresponds, almost, to the numbering system used in Microsoft * Excel for Windows and Lotus 1-2-3).

* * @return The serial number of this date.

*/ public int toSerial() { return this.serial; }

/** * Returns a <code>java.util.Date</code> equivalent to this date. * * @return The date.

*/ public Date toDate() {

final Calendar calendar = Calendar.getInstance();

calendar.set(getYYYY(), getMonth() - 1, getDayOfMonth(), 0, 0, 0);

return calendar.getTime(); }

/** * Returns the year (assume a valid range of 1900 to 9999). * * @return The year.

*/ public int getYYYY() { return this.year; }

/** * Returns the month (January = 1, February = 2, March = 3). * * @return The month of the year.

*/ public int getMonth() { return this.month; }

/** * Returns the day of the month. * * @return The day of the month. */ public int getDayOfMonth() { return this.day; }

/** * Returns a code representing the day of the week.

* <P> * The codes are defined in the {@link SerialDate} class as:

* <code>SUNDAY</code>, <code>MONDAY</code>, <code>TUESDAY</code>, * <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, and * <code>SATURDAY</code>.

* * @return A code representing the day of the week.

*/ public int getDayOfWeek() { return (this.serial + 6) % 7 + 1; } 386

Appendix B: org.jfree.date.SerialDate

Listing B-5 (continued) SpreadsheetDate.java

249

250

251

252

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277

278

279

280

281

282

283

284

285

286

287

288

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

307

308

309

310

/** * Tests the equality of this date with an arbitrary object.

* <P> * This method will return true ONLY if the object is an instance of the * {@link SerialDate} base class, and it represents the same day as this * {@link SpreadsheetDate}.

* * @param object the object to compare (<code>null</code> permitted). * * @return A boolean.

*/ public boolean equals(final Object object) {

if (object instanceof SerialDate) { final SerialDate s = (SerialDate) object; return (s.toSerial() == this.toSerial()); } else {

return false; }

}

/** * Returns a hash code for this object instance. * * @return A hash code.

*/ public int hashCode() { return toSerial(); }

/** * Returns the difference (in days) between this date and the specified * 'other' date.

* * @param other the date being compared to.

* * @return The difference (in days) between this date and the specified * 'other' date.

*/ public int compare(final SerialDate other) { return this.serial - other.toSerial(); }

/** * Implements the method required by the Comparable interface.

* * @param other the other object (usually another SerialDate).

* * @return A negative integer, zero, or a positive integer as this object * is less than, equal to, or greater than the specified object. */ public int compareTo(final Object other) { return compare((SerialDate) other); }

/**

* Returns true if this SerialDate represents the same date as the * specified SerialDate.

* Appendix B: org.jfree.date.SerialDate

387

Listing B-5 (continued) SpreadsheetDate.java

311

312

313

314

315

316

317

318

319

320

321

322

323

324

325

326

327

328

329

330

331

332

333

334

335

336

337

338

339

340

341

342

343

344

345

346

347

348

349

350

351

352

353

354

355

356

357

358

359

360

361

362

363

364

365

366

367

368

369

370

371

372

373

* @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date as * the specified SerialDate.

*/ public boolean isOn(final SerialDate other) { return (this.serial == other.toSerial()); }

/** * Returns true if this SerialDate represents an earlier date compared to * the specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents an earlier date * compared to the specified SerialDate.

*/ public boolean isBefore(final SerialDate other) { return (this.serial < other.toSerial()); }

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date * as the specified SerialDate.

*/ public boolean isOnOrBefore(final SerialDate other) { return (this.serial <= other.toSerial()); }

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date * as the specified SerialDate.

*/ public boolean isAfter(final SerialDate other) { return (this.serial > other.toSerial()); }

/** * Returns true if this SerialDate represents the same date as the * specified SerialDate.

* * @param other the date being compared to.

* * @return <code>true</code> if this SerialDate represents the same date as * the specified SerialDate.

*/ public boolean isOnOrAfter(final SerialDate other) { return (this.serial >= other.toSerial()); }

/** * Returns <code>true</code> if this {@link SerialDate} is within the 388

Appendix B: org.jfree.date.SerialDate

Listing B-5 (continued) SpreadsheetDate.java

374

375

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392

393

394

395

396

397

398

399

400

401

402

403

404

405

406

407

408

409

410

411

412

413

414

415

416

417

418

419

420

421

422

423

424

425

426

427

428

429

430

431

432

433

434

* specified range (INCLUSIVE). The date order of d1 and d2 is not * important.

* * @param d1 a boundary date for the range.

* @param d2 the other boundary date for the range.

* * @return A boolean.

*/ public boolean isInRange(final SerialDate d1, final SerialDate d2) { return isInRange(d1, d2, SerialDate.INCLUDE_BOTH); }

/** * Returns true if this SerialDate is within the specified range (caller * specifies whether or not the end-points are included). The order of d1 * and d2 is not important.

* * @param d1 one boundary date for the range.

* @param d2 a second boundary date for the range.

* @param include a code that controls whether or not the start and end * dates are included in the range.

* * @return <code>true</code> if this SerialDate is within the specified * range.

*/ public boolean isInRange(final SerialDate d1, final SerialDate d2, final int include) {

final int s1 = d1.toSerial();

final int s2 = d2.toSerial();

final int start = Math.min(s1, s2);

final int end = Math.max(s1, s2);

final int s = toSerial(); if (include == SerialDate.INCLUDE_BOTH) { return (s >= start && s <= end); } else if (include == SerialDate.INCLUDE_FIRST) {

return

(s

>=

start

&&

s

<

end);

} else if (include == SerialDate.INCLUDE_SECOND) {

return

(s

>

start

&&

s

<=

end);

} else { return (s > start && s < end); }

}

/** * Calculate the serial number from the day, month and year.

* <P> * 1-Jan-1900 = 2.

* * @param d the day.

* @param m the month.

* @param y the year.

* * @return the serial number from the day, month and year.

*/ private int calcSerial(final int d, final int m, final int y) { final int yy = ((y - 1900) * 365) + SerialDate.leapYearCount(y - 1);

int

mm

=

SerialDate.AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[m];

435

if (m > MonthConstants.FEBRUARY) { Appendix B: org.jfree.date.SerialDate

389

Listing B-5 (continued) SpreadsheetDate.java

436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 }

if (SerialDate.isLeapYear(y)) {

mm

=

mm

+

1;

}

} final int dd = d; return yy + mm + dd + 1;

}

/** * Calculate the day, month and year from the serial number. */ private void calcDayMonthYear() {

// get the year from the serial date final int days = this.serial - SERIAL_LOWER_BOUND; // overestimated because we ignored leap days final int overestimatedYYYY = 1900 + (days / 365); final int leaps = SerialDate.leapYearCount(overestimatedYYYY); final int nonleapdays = days - leaps; // underestimated because we overestimated years int underestimatedYYYY = 1900 + (nonleapdays / 365);

if (underestimatedYYYY == overestimatedYYYY) { this.year = underestimatedYYYY; } else { int ss1 = calcSerial(1, 1, underestimatedYYYY); while (ss1 <= this.serial) { underestimatedYYYY = underestimatedYYYY + 1; ss1 = calcSerial(1, 1, underestimatedYYYY); } this.year = underestimatedYYYY - 1; }

final int ss2 = calcSerial(1, 1, this.year);

int[] daysToEndOfPrecedingMonth = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH;

if (isLeapYear(this.year)) { daysToEndOfPrecedingMonth = LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH; }

// get the month from the serial date

int

int

mm

sss

=

1;

=

ss2

+

daysToEndOfPrecedingMonth[mm]

-

-

1;

while (sss < this.serial) {

mm

sss

=

mm

+

ss2

1;

=

+

daysToEndOfPrecedingMonth[mm]

1;

} this.month = mm - 1;

// what's left is d(+1); this.day = this.serial - ss2 - daysToEndOfPrecedingMonth[this.month] + 1;

} 390

Appendix B: org.jfree.date.SerialDate

Listing B-6 RelativeDayOfWeekRule.java

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4 * 5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

6 * 7 * Project Info: http://www.jfree.org/jcommon/index.html 8 * 9 * This library is free software; you can redistribute it and/or modify it 10 * under the terms of the GNU Lesser General Public License as published by 11 * the Free Software Foundation; either version 2.1 of the License, or 12 * (at your option) any later version.

13 * 14 * This library is distributed in the hope that it will be useful, but 15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 17 * License for more details.

18 * 19 * You should have received a copy of the GNU Lesser General Public 20 * License along with this library; if not, write to the Free Software 21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, 22 * USA.

23 * 24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.

25 * in the United States and other countries.] 26 * 27 * -------------------------28 * RelativeDayOfWeekRule.java 29 * -------------------------30 * (C) Copyright 2000-2003, by Object Refinery Limited and Contributors.

31 * 32 * Original Author: David Gilbert (for Object Refinery Limited); 33 * Contributor(s): -; 34 * 35 * $Id: RelativeDayOfWeekRule.java,v 1.6 2005/11/16 15:58:40 taqua Exp $ 36 * 37 * Changes (from 26-Oct-2001) 38 * -------------------------39 * 26-Oct-2001 : Changed package to com.jrefinery.date.*; 40 * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG); 41 * 42 */ 43 44 package org.jfree.date; 45 46 /** 47 * An annual date rule that returns a date for each year based on (a) a 48 * reference rule; (b) a day of the week; and (c) a selection parameter 49 * (SerialDate.PRECEDING, SerialDate.NEAREST, SerialDate.FOLLOWING).

50 * <P> 51 * For example, Good Friday can be specified as 'the Friday PRECEDING Easter 52 * Sunday'.

53 * 54 * @author David Gilbert 55 */ 56 public class RelativeDayOfWeekRule extends AnnualDateRule { 57 58 /** A reference to the annual date rule on which this rule is based. */ 59 private AnnualDateRule subrule; 60 61 /** 62 * The day of the week (SerialDate.MONDAY, SerialDate.TUESDAY, and so on). Appendix B: org.jfree.date.SerialDate

391

Listing B-6 (continued) RelativeDayOfWeekRule.java

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

*/ private int dayOfWeek;

/** Specifies which day of the week (PRECEDING, NEAREST or FOLLOWING). */ private int relative;

/** * Default constructor - builds a rule for the Monday following 1 January. */ public RelativeDayOfWeekRule() { this(new DayAndMonthRule(), SerialDate.MONDAY, SerialDate.FOLLOWING); }

/** * Standard constructor - builds rule based on the supplied sub-rule.

* * @param subrule the rule that determines the reference date.

* @param dayOfWeek the day-of-the-week relative to the reference date. * @param relative indicates *which* day-of-the-week (preceding, nearest * or following).

*/ public RelativeDayOfWeekRule(final AnnualDateRule subrule,

final int dayOfWeek, final int relative) {

this.subrule = subrule;

this.dayOfWeek = dayOfWeek;

this.relative = relative; }

/** * Returns the sub-rule (also called the reference rule).

* * @return The annual date rule that determines the reference date for this * rule.

*/ public AnnualDateRule getSubrule() { return this.subrule; }

/** * Sets the sub-rule.

* * @param subrule the annual date rule that determines the reference date * for this rule.

*/ public void setSubrule(final AnnualDateRule subrule) { this.subrule = subrule; }

/** * Returns the day-of-the-week for this rule. * * @return the day-of-the-week for this rule. */ public int getDayOfWeek() { return this.dayOfWeek; }

/**

* Sets the day-of-the-week for this rule.

* * @param dayOfWeek the day-of-the-week (SerialDate.MONDAY, * SerialDate.TUESDAY, and so on). 392

Appendix B: org.jfree.date.SerialDate

Listing B-6 (continued) RelativeDayOfWeekRule.java

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

177

178

179

180

181

182

183

184

185

186

*/ public void setDayOfWeek(final int dayOfWeek) { this.dayOfWeek = dayOfWeek; }

/** * Returns the 'relative' attribute, that determines *which* * day-of-the-week we are interested in (SerialDate.PRECEDING, * SerialDate.NEAREST or SerialDate.FOLLOWING).

* * @return The 'relative' attribute.

*/ public int getRelative() { return this.relative; }

/** * Sets the 'relative' attribute (SerialDate.PRECEDING, SerialDate.NEAREST, * SerialDate.FOLLOWING).

* * @param relative determines *which* day-of-the-week is selected by this * rule.

*/ public void setRelative(final int relative) { this.relative = relative; }

/** * Creates a clone of this rule.

* * @return a clone of this rule.

* * @throws CloneNotSupportedException this should never happen. */ public Object clone() throws CloneNotSupportedException {

final RelativeDayOfWeekRule duplicate

= (RelativeDayOfWeekRule) super.clone();

duplicate.subrule = (AnnualDateRule) duplicate.getSubrule().clone();

return duplicate; }

/** * Returns the date generated by this rule, for the specified year.

* * @param year the year (1900 &lt;= year &lt;= 9999).

* * @return The date generated by the rule for the given year (possibly * <code>null</code>).

*/ public SerialDate getDate(final int year) {

// check argument...

if ((year < SerialDate.MINIMUM_YEAR_SUPPORTED)

|| (year > SerialDate.MAXIMUM_YEAR_SUPPORTED)) {

throw new IllegalArgumentException(

"RelativeDayOfWeekRule.getDate(): year outside valid range."); }

// calculate the date...

SerialDate result = null; final SerialDate base = this.subrule.getDate(year); Appendix B: org.jfree.date.SerialDate

393

Listing B-6 (continued) RelativeDayOfWeekRule.java

187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 }

if (base != null) {

switch (this.relative) { case(SerialDate.PRECEDING):

result = SerialDate.getPreviousDayOfWeek(this.dayOfWeek, base); break; case(SerialDate.NEAREST):

result = SerialDate.getNearestDayOfWeek(this.dayOfWeek, base); break; case(SerialDate.FOLLOWING):

result = SerialDate.getFollowingDayOfWeek(this.dayOfWeek, base); break; default:

break;

}

} return result;

} 394

Appendix B: org.jfree.date.SerialDate

Listing B-7 DayDate.java (Final)

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4 * 5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

...

36 */ 37 package org.jfree.date; 38 39 import java.io.Serializable; 40 import java.util.*; 41 42 /** 43 * An abstract class that represents immutable dates with a precision of 44 * one day. The implementation will map each date to an integer that 45 * represents an ordinal number of days from some fixed origin.

46 * 47 * Why not just use java.util.Date? We will, when it makes sense. At times, 48 * java.util.Date can be *too* precise - it represents an instant in time, 49 * accurate to 1/1000th of a second (with the date itself depending on the 50 * time-zone). Sometimes we just want to represent a particular day (e.g. 21 51 * January 2015) without concerning ourselves about the time of day, or the 52 * time-zone, or anything else. That's what we've defined DayDate for.

53 * 54 * Use DayDateFactory.makeDate to create an instance.

55 * 56 * @author David Gilbert 57 * @author Robert C. Martin did a lot of refactoring.

58 */ 59 60 public abstract class DayDate implements Comparable, Serializable { 61 public abstract int getOrdinalDay(); 62 public abstract int getYear(); 63 public abstract Month getMonth(); 64 public abstract int getDayOfMonth(); 65 66 protected abstract Day getDayOfWeekForOrdinalZero(); 67 68 public DayDate plusDays(int days) { 69 return DayDateFactory.makeDate(getOrdinalDay() + days); 70 } 71 72 public DayDate plusMonths(int months) { 73 int thisMonthAsOrdinal = getMonth().toInt() - Month.JANUARY.toInt(); 74 int thisMonthAndYearAsOrdinal = 12 * getYear() + thisMonthAsOrdinal; 75 int resultMonthAndYearAsOrdinal = thisMonthAndYearAsOrdinal + months; 76 int resultYear = resultMonthAndYearAsOrdinal / 12; 77 int resultMonthAsOrdinal = resultMonthAndYearAsOrdinal % 12 + Month.JANUARY.toInt(); 78 Month resultMonth = Month.fromInt(resultMonthAsOrdinal); 79 int resultDay = correctLastDayOfMonth(getDayOfMonth(), resultMonth, resultYear); 80 return DayDateFactory.makeDate(resultDay, resultMonth, resultYear); 81 } 82 83 public DayDate plusYears(int years) { 84 int resultYear = getYear() + years; 85 int resultDay = correctLastDayOfMonth(getDayOfMonth(), getMonth(), resultYear); 86 return DayDateFactory.makeDate(resultDay, getMonth(), resultYear); 87 } 88 89 private int correctLastDayOfMonth(int day, Month month, int year) { 90 int lastDayOfMonth = DateUtil.lastDayOfMonth(month, year); 91 if (day > lastDayOfMonth) Appendix B: org.jfree.date.SerialDate

395

Listing B-7 (continued) DayDate.java (Final)

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

day = lastDayOfMonth; return day;

}

public DayDate getPreviousDayOfWeek(Day targetDayOfWeek) { int offsetToTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt(); if (offsetToTarget >= 0) offsetToTarget -= 7; return plusDays(offsetToTarget); }

public DayDate getFollowingDayOfWeek(Day targetDayOfWeek) { int offsetToTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt(); if (offsetToTarget <= 0) offsetToTarget += 7; return plusDays(offsetToTarget); }

public DayDate getNearestDayOfWeek(Day targetDayOfWeek) {

int offsetToThisWeeksTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt(); int offsetToFutureTarget = (offsetToThisWeeksTarget + 7) % 7; int offsetToPreviousTarget = offsetToFutureTarget - 7;

if (offsetToFutureTarget > 3) return plusDays(offsetToPreviousTarget); else

return plusDays(offsetToFutureTarget);

}

public DayDate getEndOfMonth() { Month month = getMonth(); int year = getYear(); int lastDay = DateUtil.lastDayOfMonth(month, year); return DayDateFactory.makeDate(lastDay, month, year); }

public Date toDate() { final Calendar calendar = Calendar.getInstance(); int ordinalMonth = getMonth().toInt() - Month.JANUARY.toInt(); calendar.set(getYear(), ordinalMonth, getDayOfMonth(), 0, 0, 0); return calendar.getTime(); }

public String toString() { return String.format("%02d-%s-%d", getDayOfMonth(), getMonth(), getYear()); }

public Day getDayOfWeek() { Day startingDay = getDayOfWeekForOrdinalZero(); int startingOffset = startingDay.toInt() - Day.SUNDAY.toInt(); int ordinalOfDayOfWeek = (getOrdinalDay() + startingOffset) % 7; return Day.fromInt(ordinalOfDayOfWeek + Day.SUNDAY.toInt()); }

public int daysSince(DayDate date) { return getOrdinalDay() - date.getOrdinalDay(); }

public boolean isOn(DayDate other) { return getOrdinalDay() == other.getOrdinalDay(); } 396

Appendix B: org.jfree.date.SerialDate

Listing B-7 (continued) DayDate.java (Final)

154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 }

public boolean isBefore(DayDate other) { return getOrdinalDay() < other.getOrdinalDay(); }

public boolean isOnOrBefore(DayDate other) { return getOrdinalDay() <= other.getOrdinalDay(); }

public boolean isAfter(DayDate other) { return getOrdinalDay() > other.getOrdinalDay(); }

public boolean isOnOrAfter(DayDate other) { return getOrdinalDay() >= other.getOrdinalDay(); }

public boolean isInRange(DayDate d1, DayDate d2) { return isInRange(d1, d2, DateInterval.CLOSED); }

public boolean isInRange(DayDate d1, DayDate d2, DateInterval interval) { int left = Math.min(d1.getOrdinalDay(), d2.getOrdinalDay()); int right = Math.max(d1.getOrdinalDay(), d2.getOrdinalDay()); return interval.isIn(getOrdinalDay(), left, right); } Appendix B: org.jfree.date.SerialDate

397

Listing B-8 Month.java (Final)

1 package org.jfree.date; 2 3 import java.text.DateFormatSymbols; 4 5 public enum Month { 6 JANUARY(1), FEBRUARY(2), MARCH(3), 7 APRIL(4), MAY(5), JUNE(6), 8 JULY(7), AUGUST(8), SEPTEMBER(9), 9 OCTOBER(10),NOVEMBER(11),DECEMBER(12); 10 private static DateFormatSymbols dateFormatSymbols = new DateFormatSymbols(); 11 private static final int[] LAST_DAY_OF_MONTH = 12 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 13 14 private int index; 15 16 Month(int index) { 17 this.index = index; 18 } 19 20 public static Month fromInt(int monthIndex) { 21 for (Month m : Month.values()) { 22 if (m.index == monthIndex) 23 return m; 24 } 25 throw new IllegalArgumentException("Invalid month index " + monthIndex); 26 } 27 28 public int lastDay() { 29 return LAST_DAY_OF_MONTH[index]; 30 } 31 32 public int quarter() { 33 return 1 + (index - 1) / 3; 34 } 35 36 public String toString() { 37 return dateFormatSymbols.getMonths()[index - 1]; 38 } 39 40 public String toShortString() { 41 return dateFormatSymbols.getShortMonths()[index - 1]; 42 } 43 44 public static Month parse(String s) { 45 s = s.trim(); 46 for (Month m : Month.values()) 47 if (m.matches(s)) 48 return m; 49 50 try { 51 return fromInt(Integer.parseInt(s)); 52 } 53 catch (NumberFormatException e) {} 54 throw new IllegalArgumentException("Invalid month " + s); 55 } 56 57 private boolean matches(String s) { 58 return s.equalsIgnoreCase(toString()) || 59 s.equalsIgnoreCase(toShortString()); 60 } 61 62 public int toInt() { 63 return index; 64 } 65 } 398

Appendix B: org.jfree.date.SerialDate

Listing B-9 Day.java (Final)

1 package org.jfree.date; 2 3 import java.util.Calendar; 4 import java.text.DateFormatSymbols; 5 6 public enum Day { 7 MONDAY(Calendar.MONDAY), 8 TUESDAY(Calendar.TUESDAY), 9 WEDNESDAY(Calendar.WEDNESDAY), 10 THURSDAY(Calendar.THURSDAY), 11 FRIDAY(Calendar.FRIDAY), 12 SATURDAY(Calendar.SATURDAY), 13 SUNDAY(Calendar.SUNDAY); 14 15 private final int index; 16 private static DateFormatSymbols dateSymbols = new DateFormatSymbols(); 17 18 Day(int day) { 19 index = day; 20 } 21 22 public static Day fromInt(int index) throws IllegalArgumentException { 23 for (Day d : Day.values()) 24 if (d.index == index) 25 return d; 26 throw new IllegalArgumentException( 27 String.format("Illegal day index: %d.", index)); 28 } 29 30 public static Day parse(String s) throws IllegalArgumentException { 31 String[] shortWeekdayNames = 32 dateSymbols.getShortWeekdays(); 33 String[] weekDayNames = 34 dateSymbols.getWeekdays(); 35 36 s = s.trim(); 37 for (Day day : Day.values()) { 38 if (s.equalsIgnoreCase(shortWeekdayNames[day.index]) || 39 s.equalsIgnoreCase(weekDayNames[day.index])) { 40 return day; 41 } 42 } 43 throw new IllegalArgumentException( 44 String.format("%s is not a valid weekday string", s)); 45 } 46 47 public String toString() { 48 return dateSymbols.getWeekdays()[index]; 49 } 50 51 public int toInt() { 52 return index; 53 } 54 } Appendix B: org.jfree.date.SerialDate

399

Listing B-10 DateInterval.java (Final)

1 package org.jfree.date; 2 3 public enum DateInterval { 4 OPEN { 5 public boolean isIn(int d, int left, int right) { 6 return d > left && d < right; 7 } 8 }, 9 CLOSED_LEFT { 10 public boolean isIn(int d, int left, int right) { 11 return d >= left && d < right; 12 } 13 }, 14 CLOSED_RIGHT { 15 public boolean isIn(int d, int left, int right) { 16 return d > left && d <= right; 17 } 18 }, 19 CLOSED { 20 public boolean isIn(int d, int left, int right) { 21 return d >= left && d <= right; 22 } 23 }; 24 25 public abstract boolean isIn(int d, int left, int right); 26 } 400

Appendix B: org.jfree.date.SerialDate

Listing B-11 WeekInMonth.java (Final)

1 package org.jfree.date; 2 3 public enum WeekInMonth { 4 FIRST(1), SECOND(2), THIRD(3), FOURTH(4), LAST(0); 5 private final int index; 6 7 WeekInMonth(int index) { 8 this.index = index; 9 } 10 11 public int toInt() { 12 return index; 13 } 14 } Appendix B: org.jfree.date.SerialDate

401

Listing B-12 WeekdayRange.java (Final)

1 package org.jfree.date; 2 3 public enum WeekdayRange { 4 LAST, NEAREST, NEXT 5 } 402

Appendix B: org.jfree.date.SerialDate

Listing B-13 DateUtil.java (Final)

1 package org.jfree.date; 2 3 import java.text.DateFormatSymbols; 4 5 public class DateUtil { 6 private static DateFormatSymbols dateFormatSymbols = new DateFormatSymbols(); 7 8 public static String[] getMonthNames() { 9 return dateFormatSymbols.getMonths(); 10 } 11 12 public static boolean isLeapYear(int year) { 13 boolean fourth = year % 4 == 0; 14 boolean hundredth = year % 100 == 0; 15 boolean fourHundredth = year % 400 == 0; 16 return fourth && (!hundredth || fourHundredth); 17 } 18 19 public static int lastDayOfMonth(Month month, int year) { 20 if (month == Month.FEBRUARY && isLeapYear(year)) 21 return month.lastDay() + 1; 22 else 23 return month.lastDay(); 24 } 25 26 public static int leapYearCount(int year) { 27 int leap4 = (year - 1896) / 4; 28 int leap100 = (year - 1800) / 100; 29 int leap400 = (year - 1600) / 400; 30 return leap4 - leap100 + leap400; 31 } 32 } Appendix B: org.jfree.date.SerialDate

403

Listing B-14 DayDateFactory.java (Final)

1 package org.jfree.date; 2 3 public abstract class DayDateFactory { 4 private static DayDateFactory factory = new SpreadsheetDateFactory(); 5 public static void setInstance(DayDateFactory factory) { 6 DayDateFactory.factory = factory; 7 } 8 9 protected abstract DayDate _makeDate(int ordinal); 10 protected abstract DayDate _makeDate(int day, Month month, int year); 11 protected abstract DayDate _makeDate(int day, int month, int year); 12 protected abstract DayDate _makeDate(java.util.Date date); 13 protected abstract int _getMinimumYear(); 14 protected abstract int _getMaximumYear(); 15 16 public static DayDate makeDate(int ordinal) { 17 return factory._makeDate(ordinal); 18 } 19 20 public static DayDate makeDate(int day, Month month, int year) { 21 return factory._makeDate(day, month, year); 22 } 23 24 public static DayDate makeDate(int day, int month, int year) { 25 return factory._makeDate(day, month, year); 26 } 27 28 public static DayDate makeDate(java.util.Date date) { 29 return factory._makeDate(date); 30 } 31 32 public static int getMinimumYear() { 33 return factory._getMinimumYear(); 34 } 35 36 public static int getMaximumYear() { 37 return factory._getMaximumYear(); 38 } 39 } 404

Appendix B: org.jfree.date.SerialDate

Listing B-15 SpreadsheetDateFactory.java (Final)

1 package org.jfree.date; 2 3 import java.util.*; 4 5 public class SpreadsheetDateFactory extends DayDateFactory { 6 public DayDate _makeDate(int ordinal) { 7 return new SpreadsheetDate(ordinal); 8 } 9 10 public DayDate _makeDate(int day, Month month, int year) { 11 return new SpreadsheetDate(day, month, year); 12 } 13 14 public DayDate _makeDate(int day, int month, int year) { 15 return new SpreadsheetDate(day, month, year); 16 } 17 18 public DayDate _makeDate(Date date) { 19 final GregorianCalendar calendar = new GregorianCalendar(); 20 calendar.setTime(date); 21 return new SpreadsheetDate( 22 calendar.get(Calendar.DATE), 23 Month.fromInt(calendar.get(Calendar.MONTH) + 1), 24 calendar.get(Calendar.YEAR)); 25 } 26 27 protected int _getMinimumYear() { 28 return SpreadsheetDate.MINIMUM_YEAR_SUPPORTED; 29 } 30 31 protected int _getMaximumYear() { 32 return SpreadsheetDate.MAXIMUM_YEAR_SUPPORTED; 33 } 34 } Appendix B: org.jfree.date.SerialDate

405

Listing B-16 SpreadsheetDate.java (Final)

1 /* ========================================================================

2

* JCommon : a free general purpose class library for the Java(tm) platform

3 * ========================================================================

4 * 5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.

6 * ...

52 * 53 */ 54 55 package org.jfree.date; 56 57 import static org.jfree.date.Month.FEBRUARY; 58 59 import java.util.*; 60 61 /** 62 * Represents a date using an integer, in a similar fashion to the 63 * implementation in Microsoft Excel. The range of dates supported is 64 * 1-Jan-1900 to 31-Dec-9999.

65 * <p/> 66 * Be aware that there is a deliberate bug in Excel that recognises the year 67 * 1900 as a leap year when in fact it is not a leap year. You can find more 68 * information on the Microsoft website in article Q181370:

69 * <p/> 70 * http://support.microsoft.com/support/kb/articles/Q181/3/70.asp 71 * <p/> 72 * Excel uses the convention that 1-Jan-1900 = 1. This class uses the 73 * convention 1-Jan-1900 = 2.

74 * The result is that the day number in this class will be different to the 75 * Excel figure for January and February 1900...but then Excel adds in an extra 76 * day (29-Feb-1900 which does not actually exist!) and from that point forward 77 * the day numbers will match.

78 * 79 * @author David Gilbert 80 */ 81 public class SpreadsheetDate extends DayDate { 82 public static final int EARLIEST_DATE_ORDINAL = 2; // 1/1/1900 83 public static final int LATEST_DATE_ORDINAL = 2958465; // 12/31/9999 84 public static final int MINIMUM_YEAR_SUPPORTED = 1900; 85 public static final int MAXIMUM_YEAR_SUPPORTED = 9999; 86 static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH = 87 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; 88 static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

{0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};

private int ordinalDay; private int day; private Month month; private int year;

public SpreadsheetDate(int day, Month month, int year) {

if (year < MINIMUM_YEAR_SUPPORTED || year > MAXIMUM_YEAR_SUPPORTED) throw new IllegalArgumentException( "The 'year' argument must be in range " + MINIMUM_YEAR_SUPPORTED + " to " + MAXIMUM_YEAR_SUPPORTED + "."); if (day < 1 || day > DateUtil.lastDayOfMonth(month, year)) throw new IllegalArgumentException("Invalid 'day' argument.");

this.year = year; this.month = month; 406

Appendix B: org.jfree.date.SerialDate

Listing B-16 (continued) SpreadsheetDate.java (Final)

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

this.day = day; ordinalDay = calcOrdinal(day, month, year);

}

public SpreadsheetDate(int day, int month, int year) { this(day, Month.fromInt(month), year); }

public SpreadsheetDate(int serial) {

if (serial < EARLIEST_DATE_ORDINAL || serial > LATEST_DATE_ORDINAL) throw new IllegalArgumentException( "SpreadsheetDate: Serial must be in range 2 to 2958465.");

ordinalDay = serial; calcDayMonthYear();

}

public int getOrdinalDay() { return ordinalDay; }

public int getYear() { return year; }

public Month getMonth() { return month; }

public int getDayOfMonth() { return day; }

protected Day getDayOfWeekForOrdinalZero() {return Day.SATURDAY;}

public boolean equals(Object object) { if (!(object instanceof DayDate)) return false;

DayDate date = (DayDate) object; return date.getOrdinalDay() == getOrdinalDay();

}

public int hashCode() { return getOrdinalDay(); }

public int compareTo(Object other) { return daysSince((DayDate) other); }

private int calcOrdinal(int day, Month month, int year) { int leapDaysForYear = DateUtil.leapYearCount(year - 1); int daysUpToYear = (year - MINIMUM_YEAR_SUPPORTED) * 365 + leapDaysForYear; int daysUpToMonth = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[month.toInt()]; if (DateUtil.isLeapYear(year) && month.toInt() > FEBRUARY.toInt()) daysUpToMonth++; int daysInMonth = day - 1; return daysUpToYear + daysUpToMonth + daysInMonth + EARLIEST_DATE_ORDINAL; } Appendix B: org.jfree.date.SerialDate

407

Listing B-16 (continued) SpreadsheetDate.java (Final)

167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 }

private void calcDayMonthYear() {

int days = ordinalDay - EARLIEST_DATE_ORDINAL; int overestimatedYear = MINIMUM_YEAR_SUPPORTED + days / 365; int nonleapdays = days - DateUtil.leapYearCount(overestimatedYear); int underestimatedYear = MINIMUM_YEAR_SUPPORTED + nonleapdays / 365;

year = huntForYearContaining(ordinalDay, underestimatedYear); int firstOrdinalOfYear = firstOrdinalOfYear(year); month = huntForMonthContaining(ordinalDay, firstOrdinalOfYear); day = ordinalDay - firstOrdinalOfYear - daysBeforeThisMonth(month.toInt());

}

private Month huntForMonthContaining(int anOrdinal, int firstOrdinalOfYear) { int daysIntoThisYear = anOrdinal - firstOrdinalOfYear; int aMonth = 1; while (daysBeforeThisMonth(aMonth) < daysIntoThisYear) aMonth++;

return Month.fromInt(aMonth - 1);

}

private int daysBeforeThisMonth(int aMonth) { if (DateUtil.isLeapYear(year)) return LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[aMonth] - 1; else return AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[aMonth] - 1; }

private int huntForYearContaining(int anOrdinalDay, int startingYear) { int aYear = startingYear; while (firstOrdinalOfYear(aYear) <= anOrdinalDay) aYear++;

return aYear - 1;

}

private int firstOrdinalOfYear(int year) { return calcOrdinal(1, Month.JANUARY, year); }

public static DayDate createInstance(Date date) {

GregorianCalendar calendar = new GregorianCalendar(); calendar.setTime(date); return new SpreadsheetDate(calendar.get(Calendar.DATE), Month.fromInt(calendar.get(Calendar.MONTH) + 1), calendar.get(Calendar.YEAR));

} This page intentionally left blank Appendix C

Cross References of Heuristics

Cross references of Smells and Heuristics. All other cross references can be deleted.

C1 .......................................................................16-276, 16-279, 17-292

C2 ......................................................... 16-279, 16-285, 16-295, 17-292

C3 ......................................................... 16-283, 16-285, 16-288, 17-293

C4 ................................................................................................. 17-293

C5 ................................................................................................. 17-293

E1 ................................................................................................. 17-294

E2 ................................................................................................. 17-294

F1 ....................................................................................14-239, 17-295

F2 ................................................................................................. 17-295

F3 ................................................................................................. 17-295

F4 ...............................14-289, 16-273, 16-285, 16-287, 16-288, 17-295

G1 ....................................................................................16-276, 17-295

G2 .......................................................................16-273, 16-274, 17-296

G3 ....................................................................................16-274, 17-296

G4 ................................................9-31, 16-279, 16-286, 16-291, 17-297

G5 ...................................9-31, 16-279, 16-286, 16-291, 16-296, 17-297

G6 ................................6-106, 16-280, 16-283, 16-284, 16-289, 16-293,

16-294, 16-296, 17-299

G7 .......................................................................16-281, 16-283, 17-300

G8 ....................................................................................16-283, 17-301

G9 ............................................16-283, 16-285, 16-286, 16-287, 17-302

G10 ..............................................5-86, 15-264, 16-276, 16-284, 17-302

G11 ..........................................15-264, 16-284, 16-288, 16-292, 17-302

G12 ............... 16-284, 16-285, 16-286, 16-287, 16-288, 16-295, 17-303

G13 .....................................................................16-286, 16-288, 17-303

G14 .....................................................................16-288, 16-292, 17-304

409 410

Appendix C: Cross References of Heuristics

G15 ..................................................................................16-288, 17-305

G16 ..................................................................................16-289, 17-306

G17 .....................................................................16-289, 17-307, 17-312

G18 ....................................................... 16-289, 16-290, 16-291, 17-308

G19 ....................................................... 16-290, 16-291, 16-292, 17-309

G20 ..................................................................................16-290, 17-309

G21 ..................................................................................16-291, 17-310

G22 ..................................................................................16-294, 17-322

G23 ..........................................................??-44, 14-239, 16-295, 17-313

G24 ..................................................................................16-296, 17-313

G25 ..................................................................................16-296, 17-314

G26 ............................................................................................... 17-316

G27 ............................................................................................... 17-316

G28 ..................................................................................15-262, 17-317

G29 ..................................................................................15-262, 17-317

G30 ..................................................................................15-263, 17-317

G31 ..................................................................................15-264, 17-318

G32 ..................................................................................15-265, 17-319

G33 .....................................................................15-265, 15-266, 17-320

G34 ...........................................................................1-40, 6-106, 17-321

G35 ......................................................................................5-90, 17-323

G36 ....................................................................................6-103, 17-324

J1 .....................................................................................16-276, 17-325

J2 ........................................................................16-278, 16-285, 17-326

J3 ........................................................................16-283, 16-285, 17-327

N1 ..............................15-264, 16-277, 16-279, 16-282, 16-287, 16-288,

16-289, 16-290, 16-294, 16-296, 17-328

N2 ....................................................................................16-277, 17-330

N3 .......................................................................16-284, 16-288, 17-331

N4 .......................................................................15-263, 16-291, 17-332

N5 ............................................................. 2-26, 14-221, 15-262, 17-332

N6 ....................................................................................15-261, 17-333

N7 ....................................................................................15-263, 17-333

T1 .......................................................................16-273, 16-274, 17-334

T2 ....................................................................................16-273, 17-334

T3 ....................................................................................16-274, 17-334

T4 ................................................................................................. 17-334

T5 .......................................................................16-274, 16-275, 17-335

T6 ....................................................................................16-275, 17-335

T7 ....................................................................................16-275, 17-335

T8 ....................................................................................16-275, 17-335

T9 ................................................................................................. 17-336 Epilogue

In 2005, while attending the Agile conference in Denver, Elisabeth Hedrickson 1 handed me a green wrist band similar to the kind that Lance Armstrong made so popular. This one said “Test Obsessed” on it. I gladly put it on and wore it proudly. Since learning TDD from Kent Beck in 1999, I have indeed become obsessed with test-driven development.

But then something strange happened. I found I could not take the band off. Not because it was physically stuck, but because it was morally stuck. The band made an overt statement about my professional ethics. It was a visible indication of my committment to writing the best code I could write. Taking it off seemed like a betrayal of those ethics and of that committment.

So it is on my wrist still. When I write code, I see it there in my peripheral vision. It is a constant reminder of the promise I made to myself to write clean code.

1. http://www.qualitytree.com/

411 This page intentionally left blank Index

## detection, 237–238 ++ (pre- or post-increment) operator, 325, 326

A

aborted computation, 109 abstract classes, 149, 271, 290 ABSTRACT FACTORY pattern, 38, 156, 273, 274 abstract interfaces, 94 abstract methods adding to ArgumentMarshaler, 234–235 modifying, 282 abstract terms, 95 abstraction classes depending on, 150 code at wrong level of, 290–291 descending one level at a time, 37 functions descending only one level of, 304–306 mixing levels of, 36–37 names at the appropriate level of, 311 separating levels of, 305 wrapping an implementation, 11 abstraction levels raising, 290 separating, 305 accessor functions, Law of Demeter and, 98 accessors, naming, 25 Active Records, 101 adapted server, 185

affinity, 84 Agile Software Development: Principles, Patterns, Practices (PPP), 15 algorithms correcting, 269–270 repeating, 48 understanding, 297–298 ambiguities in code, 301 ignored tests as, 313 amplification comments, 59 analysis functions, 265 “annotation form”, of AspectJ, 166 Ant project, 76, 77 AOP (aspect-oriented programming), 160, 163 APIs. See also public APIs calling a null-returning method from, 110 specialized for tests, 127 wrapping third-party, 108 applications decoupled from Spring, 164 decoupling from construction details, 156 infrastructure of, 163 keeping concurrency-related code separate, 181 arbitrary structure, 303–304 args array, converting into a list, 231–232 Args class constructing, 194 implementation of, 194–200 rough drafts of, 201–212, 226–231

413 414

Index

ArgsException class

listing, 198–200 merging exceptions into, 239–242 argument(s)

flag, 41

for a function, 40

in functions, 288

monadic forms of, 41

example, 71–72 experience of cleaning, 250 not making up for, 55 bad comments, 59–74 banner, gathering functions beneath, 67 base classes, 290, 291 BDUF (Big Design Up Front), 167 beans, private variables manipulated,

reducing, 43 argument lists, 43 argument objects, 43 argument types

adding, 200, 237

negative impact of, 208 ArgumentMarshaler class

100–101 Beck, Kent, 3, 34, 71, 171, 252,

adding the skeleton of, 213–214

birth of, 212 ArgumentMarshaler interface, 197–198 arrays, moving, 279 art, of clean code, 6–7 artificial coupling, 293 AspectJ language, 166 aspect-oriented programming (AOP),

160, 163 aspects

289, 296 behaviors, 288–289 Big Design Up Front (BDUF), 167 blank lines, in code, 78–79 blocks, calling functions within, 35 Booch,Grady, 8–9 boolean, passing into a function, 41 boolean arguments, 194, 288 boolean map, deleting, 224 boolean output, of tests, 132 bound resources, 183, 184 boundaries

clean, 120

exploring and learning, 116

incorrect behavior at, 289

in AOP, 160–161

separating known from unknown,

“first-class” support for, 166 assert statements, 130–131 assertEquals, 42 assertions, using a set of, 111 assignments, unaligned, 87–88 atomic operation, 323–324 attributes, 68 authors

118–119 boundary condition errors, 269 boundary conditions

encapsulating, 304

testing, 314 boundary tests, easing a migration, 118 “Bowling Game”, 312 Boy Scout Rule, 14–15, 257

of JUnit, 252

following, 284

programmers as, 13–14 authorship statements, 55 automated code instrumentation, 189–190 automated suite, of unit tests, 124

B

bad code, 3–4. See also dirty code; messy code degrading effect of, 250

satisfying, 265 broken windows metaphor, 8 bucket brigade, 303 BUILD-OPERATE-CHECK pattern, 127 builds, 287 business logic, separating from error

handling, 109 bylines, 68 byte-manipulation libraries, 161,

162–163 Index

415

C

The C++ Programming Language, 7 calculations, breaking into intermediate values, 296 call stack, 324 Callable interface, 326 caller, cluttering, 104 calling hierarchy, 106 calls, avoiding chains of, 98 caring, for code, 10 Cartesian points, 42 CAS operation, as atomic, 328 change(s) isolating from, 149–150 large number of very tiny, 213 organizing for, 147–150 tests enabling, 124 change history, deleting, 270 check exceptions, in Java, 106 circular wait, 337, 338–339 clarification, comments as, 57 clarity, 25, 26 class names, 25 classes cohesion of, 140–141 creating for bigger concepts, 28–29 declaring instance variables, 81 enforcing design and business rules, 115 exposing internals of, 294 instrumenting into ConTest, 342 keeping small, 136, 175 minimizing the number of, 176 naming, 25, 138 nonthread-safe, 328–329 as nouns of a language, 49 organization of, 136 organizing to reduce risk of change, 147 supporting advanced concurrency design, 183 classification, of errors, 107

clean boundaries, 120 clean code art of, 6–7 described, 7–12 writing, 6–7 clean tests, 124–127 cleanliness acquired sense of, 6–7 tied to tests, 9 cleanup, of code, 14–15 clever names, 26 client, using two methods, 330 client code, connecting to a server, 318 client-based locking, 185, 329, 330–332 clientScheduler, 320 client/server application, concurrency in, 317–321 Client/Server nonthreaded, code for, 343–346 client-server using threads, code changes, 346–347 ClientTest.java, 318, 344–346 closing braces, comments on, 67–68 Clover, 268, 269 clutter Javadocs as, 276 keeping free of, 293 code, 2 bad, 3–4 Beck's rules of, 10 commented-out, 68–69, 287 dead, 292 explaining yourself in, 55 expressing yourself in, 54 formatting of, 76 implicity of, 18–19 instrumenting, 188, 342 jiggling, 190 making readable, 311 necessity of, 2 reading from top to bottom, 37 simplicity of, 18, 19 technique for shrouding, 20 416

Index

code, continued third-party, 114–115 width of lines in, 85–90 at wrong level of abstraction, 290–291 code bases, dominated by error handling, 103 code changes, comments not always following, 54 code completion, automatic, 20 code coverage analysis, 254–256 code instrumentation, 188–190 “code sense”, 6, 7 code smells, listing of, 285–314 coding standard, 299 cohesion of classes, 140–141 maintaining, 141–146 command line arguments, 193–194 commands, separating from queries, 45–46 comment header standard, 55–56 comment headers, replacing, 70 commented-out code, 68–69, 287 commenting style, example of bad, 71–72 comments amplifying importance of something, 59 bad, 59–74 deleting, 282 as failures, 54 good, 55–59 heuristics on, 286–287 HTML, 69 inaccurate, 54 informative, 56 journal, 63–64 legal, 55–56 mandated, 63 misleading, 63 mumbling, 59–60 as a necessary evil, 53–59 noise, 64–66 not making up for bad code, 55 obsolete, 286 poorly written, 287 proper use of, 54

redundant, 60–62, 272, 275, 286–287 restating the obvious, 64 separated from code, 54 TODO, 58–59 too much information in, 70 venting in, 65 writing, 287 “communication gap”, minimizing, 168 Compare and Swap (CAS) operation, 327–328 ComparisonCompactor module, 252–265 defactored, 256–261 final, 263–265 interim, 261–263 original code, 254–256 compiler warnings, turning off, 289 complex code, demonstrating failures in, 341 complexity, managing, 139–140 computer science (CS) terms, using for names, 27 concepts keeping close to each other, 80 naming, 19 one word per, 26 separating at different levels, 290 spelling similar similarly, 20 vertical openness between, 78–79 conceptual affinity, of code, 84 concerns cross-cutting, 160–161 separating, 154, 166, 178, 250 concrete classes, 149 concrete details, 149 concrete terms, 94 concurrency defense principles, 180–182 issues, 190 motives for adopting, 178–179 myths and misconceptions about, 179–180 concurrency code compared to nonconcurrency-related code, 181 focusing, 321 Index

417

concurrent algorithms, 179 concurrent applications, partition behavior, 183 concurrent code breaking, 329–333 defending from problems of, 180 flaws hiding in, 188 concurrent programming, 180 Concurrent Programming in Java: Design Principles and Patterns, 182, 342 concurrent programs, 178 concurrent update problems, 341 ConcurrentHashMap implementation, 183 conditionals avoiding negative, 302 encapsulating, 257–258, 301 configurable data, 306 configuration constants, 306 consequences, warning of, 58 consistency in code, 292 of enums, 278 in names, 40 consistent conventions, 259 constants versus enums, 308–309 hiding, 308 inheriting, 271, 307–308 keeping at the appropriate level, 83 leaving as raw numbers, 300 not inheriting, 307–308 passing as symbols, 276 turning into enums, 275–276 construction moving all to main, 155, 156 separating with factory, 156 of a system, 154 constructor arguments, 157 constructors, overloading, 25 consumer threads, 184 ConTest tool, 190, 342 context adding meaningful, 27–29 not adding gratuitous, 29–30 providing with exceptions, 107

continuous readers, 184 control variables, within loop statements,

80–81 convenient idioms, 155 convention(s)

following standard, 299–300

over configuration, 164

structure over, 301

using consistent, 259 convoluted code, 175 copyright statements, 55 cosmic-rays. See one-offs CountDownLatch class, 183 coupling. See also decoupling; temporal

coupling; tight coupling

artificial, 293

hidden temporal, 302–303

lack of, 150 coverage patterns, testing, 314 coverage tools, 313 “crisp abstraction”, 8–9 cross-cutting concerns, 160 Cunningham, Ward, 11–12 cuteness, in code, 26

D

dangling false argument, 294 data abstraction, 93–95 copies of, 181–182 encapsulation, 181 limiting the scope of, 181 sets processed in parallel, 179 types, 97, 101 data structures. See also structure(s) compared to objects, 95, 97 defined, 95 interfaces representing, 94 treating Active Records as, 101 data transfer-objects (DTOs), 100–101, 160 database normal forms, 48 DateInterval enum, 282–283 DAY enumeration, 277 418

Index

DayDate class, running SerialDate as, 271 DayDateFactory, 273–274

dead code, 288, 292 dead functions, 288 deadlock, 183, 335–339 deadly embrace. See circular wait debugging, finding deadlocks, 336 decision making, optimizing, 167–168 decisions, postponing, 168 declarations, unaligned, 87–88 DECORATOR objects, 164 DECORATOR pattern, 274 decoupled architecture, 167 decoupling, from construction

details, 156 decoupling strategy, concurrency

as, 178 default constructor, deleting, 276 degradation, preventing, 14 deletions, as the majority of

changes, 250 density, vertical in code, 79–80 dependencies

finding and breaking, 250

description of a class, 138 overloading the structure of code into, 310 descriptive names

choosing, 309–310

using, 39–40 design(s)

of concurrent algorithms, 179

minimally coupled, 167

principles of, 15 design patterns, 290 details, paying attention to, 8 DI (Dependency Injection), 157 Dijkstra, Edsger, 48 dining philosophers execution model,

184–185 DIP (Dependency Inversion Principle),

15, 150 dirty code. See also bad code;

injecting, 157

logical, 282

making logical physical, 298–299

between methods, 329–333

between synchronized

methods, 185 Dependency Injection (DI), 157 Dependency Inversion Principle (DIP),

15, 150 dependency magnet, 47 dependent functions, formatting, 82–83 derivatives

base classes depending on, 291

base classes knowing about, 273

messy code dirty code, cleaning, 200 dirty tests, 123 disinformation, avoiding, 19–20 distance, vertical in code, 80–84 distinctions, making meaningful, 20–21 domain-specific languages (DSLs),

168–169 domain-specific testing language, 127 DoubleArgumentMarshaler class, 238 DRY principle (Don't Repeat Yourself),

181, 289 DTOs (data transfer objects), 100–101, 160 dummy scopes, 90 duplicate if statements, 276 duplication

of code, 48

in code, 289–290

eliminating, 173–175

of the exception class, 48

moving set functions into, 232,

focusing on, 10

forms of, 173, 290

233–235

reduction of, 48

pushing functionality into, 217

strategies for eliminating, 48 Index

419

dyadic argument, 40 dyadic functions, 42 dynamic proxies, 161

E

e, as a variable name, 22 Eclipse, 26 edit sessions, playing back, 13–14 efficiency, of code, 7 EJB architecture, early as over-engineered,

167 EJB standard, complete overhaul of, 164 EJB2 beans, 160 EJB3, Bank object rewritten in, 165–166 “elegant” code, 7 emergent design, 171–176 encapsulation, 136

error messages, 107, 250 error processing, testing, 238–239 errorMessage method, 250 errors. See also boundary condition errors;

spelling errors; string comparison

errors

classifying, 107 Evans, Eric, 311 events, 41 exception classification, 107 exception clauses, 107–108 exception management code, 223 exceptions

instead of return codes, 103–105

narrowing the type of, 105–106

preferring to error codes, 46

providing context with, 107

separating from Args, 242–250

of boundary conditions, 304

breaking, 106–107

of conditionals, 301 encodings, avoiding, 23–24, 312–313 entity bean, 158–160 enum(s)

changing MonthConstants to, 272

using, 308–309 enumeration, moving, 277 environment, heuristics on, 287 environment control system, 128–129 envying, the scope of a class, 293 error check, hiding a side effect, 258 Error class, 47–48 error code constants, 198–200 error codes

implying a class or enum, 47–48

preferring exceptions to, 46

throwing, 104–105, 194

unchecked, 106–107 execution, possible paths of, 321–326 execution models, 183–185 Executor framework, 326–327 ExecutorClientScheduler.java, 321 explanation, of intent, 56–57 explanatory variables, 296–297 explicitness, of code, 19 expressive code, 295 expressiveness

in code, 10–11

ensuring, 175–176 Extract Method refactoring, 11 Extreme Programming Adventures

in C#, 10 Extreme Programming Installed, 10 “eye-full”, code fitting into, 79–80

returning, 103–104

reusing old, 48

separating from the Args module,

242–250 error detection, pushing to the edges, 109 error flags, 103–104 error handling, 8, 47–48

F

factories, 155–156 factory classes, 273–275 failure to express ourselves in code, 54 420

Index

failure, continued patterns of, 314 tolerating with no harm, 330 false argument, 294 fast tests, 132 fast-running threads, starving longer

running, 183 fear, of renaming, 30 Feathers, Michael, 10 feature envy

eliminating, 293–294

smelling of, 278 file size, in Java, 76 final keywords, 276 F.I.R.S.T. acronym, 132–133 First Law, of TDD, 122 FitNesse project

coding style for, 90

file sizes, 76, 77

function in, 32–33

invoking all tests, 224 flag arguments, 41, 288 focussed code, 8 foreign code. See third-party code formatting

horizontal, 85–90

purpose of, 76

Uncle Bob’s rules, 90–92

vertical, 76–85 formatting style, for a team of

developers, 90 Fortran, forcing encodings, 23 Fowler, Martin, 285, 293 frame, 324 function arguments, 40–45 function call dependencies, 84–85 function headers, 70 function signature, 45 functionality, placement of, 295–296 functions

breaking into smaller, 141–146

calling within a block, 35

descending one level of abstraction, 304–306 doing one thing, 35–36, 302 dyadic, 42 eliminating extraneous if statements, 262 establishing the temporal nature of, 260 formatting dependent, 82–83 gathering beneath a banner, 67 heuristics on, 288 intention-revealing, 19 keeping small, 175 length of, 34–35 moving, 279 naming, 39, 297 number of arguments in, 288 one level of abstraction per, 36–37 in place of comments, 67 renaming for clarity, 258 rewriting for clarity, 258–259 sections within, 36 small as better, 34 structured programming with, 49 understanding, 297–298 as verbs of a language, 49 writing, 49 futures, 326

G

dead, 288

defining private, 292

Gamma, Eric, 252 general heuristics, 288–307 generated byte-code, 180 generics, improving code readability, 115 get functions, 218 getBoolean function, 224 GETFIELD instruction, 325, 326 getNextId method, 326 getState function, 129 Gilbert, David, 267, 268 given-when-then convention, 130 glitches. See one-offs Index

421

global setup strategy, 155 “God class”, 136–137 good comments, 55–59 goto statements, avoiding, 48, 49 grand redesign, 5 gratuitous context, 29–30

exposing, 94 hiding, 94 wrapping an abstraction, 11 Implementation Patterns, 3, 296 implicity, of code, 18 import lists

avoiding long, 307

H

hand-coded instrumentation, 189 HashTable, 328–329 headers. See comment headers; function

headers heuristics

cross references of, 286, 409

shortening in SerialDate, 270 imports, as hard dependencies, 307 imprecision, in code, 301 inaccurate comments, 54 inappropriate information, in

general, 288–307

listing of, 285–314 hidden temporal coupling, 259, 302–303 hidden things, in a function, 44 hiding

implementation, 94

comments, 286 inappropriate static methods, 296 include method, 48 inconsistency, in code, 292 inconsistent spellings, 20 incrementalism, 212–214 indent level, of a function, 35 indentation, of code, 88–89 indentation rules, 89 independent tests, 132 information

structures, 99 hierarchy of scopes, 88 HN. See Hungarian Notation horizontal alignment, of code, 87–88 horizontal formatting, 85–90 horizontal white space, 86 HTML, in source code, 69 Hungarian Notation (HN), 23–24, 295 Hunt, Andy, 8, 289 hybrid structures, 99

inappropriate, 286

too much, 70, 291–292 informative comments, 56 inheritance hierarchy, 308 inobvious connection, between a comment

and code, 70 input arguments, 41 instance variables

in classes, 140

declaring, 81

I

hiding the declaration of, 81–82

passing as function

if statements duplicate, 276 eliminating, 262 if-else chain appearing again and again, 290 eliminating, 233 ignored tests, 313 implementation duplication of, 173 encoding, 24

arguments, 231

proliferation of, 140 instrumented classes, 342 insufficient tests, 313 integer argument(s)

defining, 194

integrating, 224–225 integer argument functionality,

moving into ArgumentMarshaler,

215–216 422

Index

integer argument type, adding to Args, 212 integers, pattern of changes for, 220 IntelliJ, 26 intent

Java programmers, encoding not needed, 24 Java proxies, 161–163 Java source files, 76–77 javadocs

explaining in code, 55

explanation of, 56–57

as clutter, 276

in nonpublic code, 71

obscured, 295 intention-revealing function, 19 intention-revealing names, 18–19 interface(s)

preserving formatting in, 270

in public APIs, 59

requiring for every function, 63 java.util.concurrent package, collections

defining local or remote, 158–160

encoding, 24

implementing, 149–150

representing abstract concerns, 150

turning ArgumentMarshaler into, 237

well-defined, 291–292

in, 182–183 JBoss AOP, proxies in, 163 JCommon library, 267 JCommon unit tests, 270 JDepend project, 76, 77 JDK proxy, providing persistence support,

writing, 119 internal structures, objects hiding, 97 intersection, of domains, 160 intuition, not relying on, 289 inventor of C++, 7 Inversion of Control (IoC), 157 InvocationHandler object, 162 I/O bound, 318 isolating, from change, 149–150 isxxxArg methods, 221–222 iterative process, refactoring as, 265

161–163 Jeffries, Ron, 10–11, 289 jiggling strategies, 190 JNDI lookups, 157 journal comments, 63–64 JUnit, 34 JUnit framework, 252–265 Junit project, 76, 77 Just-In-Time Compiler, 180

K

J

keyword form, of a function name, 43

jar files, deploying derivatives and bases in, 291 Java aspects or aspect-like mechanisms, 161–166 heuristics on, 307–309 as a wordy language, 200 Java 5, improvements for concurrent development, 182–183 Java 5 Executor framework, 320–321 Java 5 VM, nonblocking solutions in, 327–328 Java AOP frameworks, 163–166

L

L, lower-case in variable names, 20 language design, art of programming as, 49 languages

appearing to be simple, 12

level of abstraction, 2

multiple in one source file, 288

multiples in a comment, 270 last-in, first-out (LIFO) data structure,

operand stack as, 324 Law of Demeter, 97–98, 306 Index

423

LAZY INITIALIZATION/ EVALUATION idiom, 154 LAZY-INITIALIZATION, 157 Lea, Doug, 182, 342 learning tests, 116, 118 LeBlanc’s law, 4 legacy code, 307 legal comments, 55–56 level of abstraction, 36–37 levels of detail, 99 lexicon, having a consistent, 26 lines of code

managers, role of, 6 mandated comments, 63 manual control, over a serial ID, 272

Map

adding for ArgumentMarshaler, 221 methods of, 114 maps, breaking the use of, 222–223 marshalling implementation,

214–215 meaningful context, 27–29 member variables

f prefix for, 257

duplicating, 173

prefixing, 24

width of, 85 list(s)

of arguments, 43

meaning specific to programmers, 19

returning a predefined immutable, 110 literate code, 9 literate programming, 9 Literate Programming, 141 livelock, 183, 338 local comments, 69–70 local variables, 324

renaming for clarity, 259 mental mapping, avoiding, 25 messy code. See also bad code; dirty code

total cost of owning, 4–12 method invocations, 324 method names, 25 methods

affecting the order of execution, 188

calling a twin with a flag, 278

changing from static to instance, 280

of classes, 140

declaring, 292

dependencies between, 329–333

at the top of each function, 80 lock & wait, 337, 338 locks, introducing, 185 log4j package, 116–118 logical dependencies, 282, 298–299 LOGO language, 36 long descriptive names, 39 long names, for long scopes, 312 loop counters, single-letter names for, 25

M

magic numbers obscuring intent, 295 replacing with named constants, 300–301 main function, moving construction to, 155, 156

eliminating duplication between,

173–174

minimizing assert statements in, 176

naming, 25

tests exposing bugs in, 269 minimal code, 9 misleading comments, 63 misplaced responsibility, 295–296, 299 MOCK OBJECT, assigning, 155 monadic argument, 40 monadic forms, of arguments, 41 monads, converting dyads into, 42 Monte Carlo testing, 341 Month enum, 278 MonthConstants class, 271 multithread aware, 332 multithread-calculation, of throughput,

335 424

Index

multithreaded code, 188, 339–342 mumbling, 59–60 mutators, naming, 25 mutual exclusion, 183, 336, 337

Newkirk, Jim, 116 newspaper metaphor, 77–78 niladic argument, 40 no preemption, 337 noise

comments, 64–66

N

named constants, replacing magic numbers, 300–301 name-length-challenged languages, 23 names abstractions, appropriate level of, 311 changing, 40 choosing, 175, 309–310 of classes, 270–271 clever, 26 descriptive, 39–40 of functions, 297 heuristics on, 309–313 importance of, 309–310 intention-revealing, 18–19 length of corresponding to scope, 22–23 long names for long scopes, 312 making unambiguous, 258 problem domain, 27 pronounceable, 21–22 rules for creating, 18–30 searchable, 22–23 shorter generally better than longer, 30 solution domain, 27 with subtle differences, 20 unambiguous, 312 at the wrong level of abstraction, 271 naming, classes, 138 naming conventions, as inferior to structures, 301 navigational methods, in Active Records, 101 near bugs, testing, 314 negative conditionals, avoiding, 302 negatives, 258 nested structures, 46

scary, 66

words, 21 nomenclature, using standard, 311–312 nonblocking solutions, 327–328 nonconcurrency-related code, 181 noninformative names, 21 nonlocal information, 69–70 nonpublic code, javadocs in, 71 nonstatic methods, preferred to static, 296 nonthreaded code, getting working

first, 187 nonthread-safe classes, 328–329 normal flow, 109

null

not passing into methods, 111–112 not returning, 109–110 passed by a caller accidentally, 111 null detection logic, for ArgumentMarshaler, 214 NullPointerException, 110, 111 number-series naming, 21

O

Object Oriented Analysis and Design with Applications, 8 object-oriented design, 15 objects

compared to data structures, 95, 97

compared to data types and proce-

dures, 101

copying read-only, 181

defined, 95 obscured intent, 295 obsolete comments, 286 obvious behavior, 288–289 obvious code, 12 Index

425

“Once and only once” principle, 289 “ONE SWITCH” rule, 299 one thing, functions doing, 35–36, 302 one-offs, 180, 187, 191 OO code, 97 OO design, 139 Open Closed Principle (OCP), 15, 38

by checked exceptions, 106

supporting, 149 operand stack, 324 operating systems, threading policies, 188 operators, precedence of, 86 optimistic locking, 327 optimizations, LAZY-EVALUATION

as, 157 optimizing, decision making, 167–168 orderings, calculating the possible, 322–323 organization

performance of a client/server pair, 318 concurrency improving, 179 of server-based locking, 333 permutations, calculating, 323 persistence, 160, 161 pessimistic locking, 327 phraseology, in similar names, 40 physicalizing, a dependency, 299 Plain-Old Java Objects. See POJOs platforms, running threaded code, 188 pleasing code, 7 pluggable thread-based code, 187 POJO system, agility provided by, 168 POJOs (Plain-Old Java Objects)

creating, 187

implementing business logic, 162

separating threaded-aware code, 190

for change, 147–150

of classes, 136

in Spring, 163

managing complexity, 139–140 outbound tests, exercising an interface, 118 output arguments, 41, 288

avoiding, 45

writing application domain logic, 166 polyadic argument, 40 polymorphic behavior, of functions, 296 polymorphic changes, 96–97 polymorphism, 37, 299 position markers, 67 positives

need for disappearing, 45 outputs, arguments as, 45 overhead, incurred by concurrency, 179 overloading, of code with description, 310

P

paperback model, as an academic model, 27 parameters, taken by instructions, 324 parse operation, throwing an

exception, 220 partitioning, 250 paths of execution, 321–326 pathways, through critical sections, 188 pattern names, using standard, 175 patterns

as easier to understand, 258

expressing conditionals as, 302

of decisions, 301precision

as the point of all naming, 30 predicates, naming, 25 preemption, breaking, 338 prefixes

for member variables, 24

as useless in today’s environments,

312–313 pre-increment operator, ++, 324, 325, 326 “prequel”, this book as, 15 principle of least surprise, 288–289, 295 principles, of design, 15 PrintPrimes program, translation into

of failure, 314

as one kind of standard, 311

Java, 141 private behavior, isolating, 148–149 426

Index

private functions, 292 private method behavior, 147 problem domain names, 27 procedural code, 97 procedural shape example, 95–96 procedures, compared to objects, 101 process function, repartitioning, 319–320 process method, I/O bound, 319 processes, competing for resources, 184 processor bound, code as, 318 producer consumer execution model, 184 producer threads, 184 production environment, 127–130 productivity, decreased by messy code, 4 professional programmer, 25 professional review, of code, 268 programmers

as authors, 13–14

conundrum faced by, 6

responsibility for messes, 5–6

unprofessional, 5–6 programming

defined, 2

structured, 48–49 programs, getting them to work, 201 pronounceable names, 21–22 protected variables, avoiding, 80 proxies, drawbacks of, 163 public APIs, javadocs in, 59 puns, avoiding, 26–27 PUTFIELD instruction, as atomic, 325

Q

queries, separating from commands, 45–46

R

random jiggling, tests running, 190 range, including end-point dates in, 276 readability

of clean tests, 124 of code, 76

Dave Thomas on, 9 improving using generics, 115 readability perspective, 8 readers of code, 13–14 continuous, 184 readers-writers execution model, 184 reading clean code, 8 code from top to bottom, 37 versus writing, 14 reboots, as a lock up solution, 331 recommendations, in this book, 13 redesign, demanded by the team, 5 redundancy, of noise words, 21 redundant comments, 60–62, 272, 275, 286–287 ReentrantLock class, 183 refactored programs, as longer, 146 refactoring Args, 212 code incrementally, 172 as an iterative process, 265 putting things in to take out, 233 test code, 127 Refactoring (Fowler), 285 renaming, fear of, 30 repeatability, of concurrency bugs, 180 repeatable tests, 132 requirements, specifying, 2 resetId, byte-code generated for, 324–325 resources bound, 183 processes competing for, 184 threads agreeing on a global ordering of, 338 responsibilities counting in classes, 136 definition of, 138 identifying, 139 misplaced, 295–296, 299 splitting a program into main, 146 return codes, using exceptions instead, 103–105 Index

427

reuse, 174 risk of change, reducing, 147 robust clear code, writing, 112 rough drafts, writing, 200 runnable interface, 326 run-on expressions, 295 run-on journal entries, 63–64 runtime logic, separating startup from, 154

S

safety mechanisms, overridden, 289 scaling up, 157–161 scary noise, 66 schema, of a class, 194 schools of thought, about clean code,

12–13 scissors rule, in C++, 81 scope(s)

server application, 317–318, 343–344 server code, responsibilities of, 319 server-based locking, 329

as preferred, 332–333

with synchronized methods, 185 “Servlet” model, of Web applications, 178 Servlets, synchronization problems, 182 set functions, moving into appropriate

derivatives, 232, 233–235 setArgument, changing, 232–233 setBoolean function, 217 setter methods, injecting dependencies,

157 setup strategy, 155 SetupTeardownIncluder.java listing,

50–52 shape classes, 95–96 shared data, limiting access, 181 shared variables

defined by exceptions, 105

dummy, 90

envying, 293

expanding and indenting, 89

hierarchy in a source file, 88

limiting for data, 181

names related to the length of,

method updating, 328

reducing the scope of, 333 shotgun approach, hand-coded instrumen-

tation as, 189 shut-down code, 186 shutdowns, graceful, 186 side effects

22–23, 312

having none, 44

of shared variables, 333 searchable names, 22–23 Second Law, of TDD, 122 sections, within functions, 36 selector arguments, avoiding, 294–295 self validating tests, 132 Semaphore class, 183 semicolon, making visible, 90 “serial number”, SerialDate using, 271 SerialDate class

names describing, 313 Simmons, Robert, 276 simple code, 10, 12 Simple Design, rules of, 171–176 simplicity, of code, 18, 19 single assert rule, 130–131 single concepts, in each test function,

131–132 Single Responsibility Principle (SRP), 15,

138–140

making it right, 270–284

naming of, 270–271

refactoring, 267–284 SerialDateTests class, 268 serialization, 272 server, threads created by, 319–321

applying, 321

breaking, 155

as a concurrency defense principle,

181

recognizing violations of, 174

server violating, 320 428

Index

Single Responsibility Principle (SRP), continued Sql class violating, 147 supporting, 157 in test classes conforming to, 172 violating, 38 single value, ordered components of, 42 single-letter names, 22, 25 single-thread calculation, of throughput,

334 SINGLETON pattern, 274 small classes, 136 Smalltalk Best Practice Patterns, 296 smart programmer, 25 software project, maintenance of, 175 software systems. See also system(s)

compared to physical systems, 158 SOLID class design principle, 150 solution domain names, 27 source code control systems, 64, 68, 69 source files

compared to newspaper articles,

starvation, 183, 184, 338 static function, 279 static import, 308 static methods, inappropriate, 296 The Step-down Rule, 37 stories, implementing only today’s, 158 STRATEGY pattern, 290 string arguments, 194, 208–212, 214–225 string comparison errors, 252 StringBuffers, 129 Stroustrup, Bjarne, 7–8 structure(s). See also data structures

hiding, 99

hybrid, 99

making massive changes to, 212

over convention, 301 structured programming, 48–49 SuperDashboard class, 136–137 swapping, as permutations, 323 switch statements

burying, 37, 38

considering polymorphism

77–78

before, 299

multiple languages in, 288 Sparkle program, 34 spawned threads, deadlocked, 186 special case objects, 110 SPECIAL CASE PATTERN, 109 specifications, purpose of, 2 spelling errors, correcting, 20 SpreadsheetDateFactory, 274–275 Spring AOP, proxies in, 163 Spring Framework, 157 Spring model, following EJB3, 165 Spring V2.5 configuration file, 163–164 spurious failures, 187 Sql class, changing, 147–149 square root, as the iteration limit, 74 SRP. See Single Responsibility Principle standard conventions, 299–300 standard nomenclature, 175, 311–312 standards, using wisely, 168 startup process, separating from runtime

reasons to tolerate, 38–39 switch/case chain, 290 synchronization problems, avoiding with

Servlets, 182 synchronized block, 334 synchronized keyword, 185

adding, 323

always acquiring a lock, 328

introducing a lock via, 331

protecting a critical section

in code, 181 synchronized methods, 185 synchronizing, avoiding, 182 synthesis functions, 265 system(s). See also software systems

file sizes of significant, 77

keeping running during development,

213

needing domain-specific, 168 system architecture, test driving,

logic, 154

166–167 Index

429

system failures, not ignoring one-offs, 187 system level, staying clean at, 154 system-wide information, in a local

comment, 69–70

T

tables, moving, 275 target deployment platforms, running tests on, 341 task swapping, encouraging, 188 TDD (Test Driven Development), 213 building logic, 106 as fundamental discipline, 9 laws of, 122–123 team rules, 90 teams coding standard for every, 299–300 slowed by messy code, 4 technical names, choosing, 27 technical notes, reserving comments for, 286 TEMPLATE METHOD pattern addressing duplication, 290 removing higher-level duplication, 174–175 using, 130 temporal coupling. See also coupling exposing, 259–260 hidden, 302–303 side effect creating, 44 temporary variables, explaining, 279–281 test cases adding to check arguments, 237 in ComparisonCompactor, 252–254 patterns of failure, 269, 314 turning off, 58 test code, 124, 127 TEST DOUBLE, assigning, 155 Test Driven Development. See TDD test driving, architecture, 166–167 test environment, 127–130

test functions, single concepts in, 131–132 test implementation, of an interface, 150 test suite automated, 213 of unit tests, 124, 268 verifying precise behavior, 146 testable systems, 172 test-driven development. See TDD testing arguments making harder, 40 construction logic mixed with runtime, 155 testing language, domain-specific, 127 testNG project, 76, 77 tests clean, 124–127 cleanliness tied to, 9 commented out for SerialDate, 268–270 dirty, 123 enabling the -ilities, 124 fast, 132 fast versus slow, 314 heuristics on, 313–314 ignored, 313 independent, 132 insufficient, 313 keeping clean, 123–124 minimizing assert statements in, 130–131 not stopping trivial, 313 refactoring, 126–127 repeatable, 132 requiring more than one step, 287 running, 341 self validating, 132 simple design running all, 172 suite of automated, 213 timely, 133 writing for multithreaded code, 339–342 writing for threaded code, 186–190 writing good, 122–123 430

Index

Third Law, of TDD, 122 third-party code integrating, 116 learning, 116 using, 114–115 writing tests for, 116 this variable, 324 Thomas, Dave, 8, 9, 289 thread(s) adding to a method, 322 interfering with each other, 330 making as independent as possible, 182 stepping on each other, 180, 326 taking resources from other threads, 338 thread management strategy, 320 thread pools, 326 thread-based code, testing, 342 threaded code making pluggable, 187 making tunable, 187–188 symptoms of bugs in, 187 testing, 186–190 writing in Java 5, 182–183 threading adding to a client/server application, 319, 346–347 problems in complex systems, 342 thread-safe collections, 182–183, 329 throughput causing starvation, 184 improving, 319 increasing, 333–335 validating, 318 throws clause, 106 tiger team, 5 tight coupling, 172 time, taking to go fast, 6 Time and Money project, 76 file sizes, 77 timely tests, 133

timer program, testing, 121–122 “TO” keyword, 36 TO paragraphs, 37 TODO comments, 58–59 tokens, used as magic numbers, 300 Tomcat project, 76, 77 tools

ConTest tool, 190, 342

coverage, 313

handling proxy boilerplate, 163

testing thread-based code, 342 train wrecks, 98–99 transformations, as return values, 41 transitive navigation, avoiding, 306–307 triadic argument, 40 triads, 42 try blocks, 105 try/catch blocks, 46–47, 65–66 try-catch-finally statement, 105–106 tunable threaded-based code, 187–188 type encoding, 24

U

ubiquitous language, 311–312 unambiguous names, 312 unchecked exceptions, 106–107 unencapsulated conditional, encapsulating, 257 unit testing, isolated as difficult, 160 unit tests, 124, 175, 268 unprofessional programming, 5–6 uppercase C, in variable names, 20 usability, of newspapers, 78 use, of a system, 154 users, handling concurrently, 179

V

validation, of throughput, 318 variable names, single-letter, 25 Index

431

variables 1 based versus zero based, 261 declaring, 80, 81, 292 explaining temporary, 279–281 explanatory, 296–297 keeping private, 93 local, 292, 324 moving to a different class, 273 in place of comments, 67 promoting to instance variables of classes, 141 with unclear context, 28 venting, in comments, 65 verbs, keywords and, 43 Version class, 139 versions, not deserializing across, 272 vertical density, in code, 79–80 vertical distance, in code, 80–84 vertical formatting, 76–85 vertical openness, between concepts, 78–79 vertical ordering, in code, 84–85 vertical separation, 292

W

wading, through bad code, 3 Web containers, decoupling provided

by, 178 what, decoupling from when, 178 white space, use of horizontal, 86 wildcards, 307 Working Effectively with Legacy

Code, 10 “working” programs, 201 workmanship, 176 wrappers, 108 wrapping, 108 writers, starvation of, 184 “Writing Shy Code”, 306

X

XML

deployment descriptors, 160 “policy” specified configuration files, 164
